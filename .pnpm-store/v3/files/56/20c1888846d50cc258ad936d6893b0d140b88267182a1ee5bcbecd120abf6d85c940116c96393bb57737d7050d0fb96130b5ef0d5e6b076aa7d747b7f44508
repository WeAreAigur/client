"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../turbo-utils/dist/index.js
var require_dist = __commonJS({
  "../turbo-utils/dist/index.js"(exports, module2) {
    "use strict";
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __esm = (fn, res) => function __init() {
      return fn && (res = (0, fn[__getOwnPropNames2(fn)[0]])(fn = 0)), res;
    };
    var __commonJS2 = (cb, mod) => function __require() {
      return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
    };
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
      isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var init_cjs_shims = __esm({
      "../../node_modules/.pnpm/tsup@5.12.9_typescript@4.8.3/node_modules/tsup/assets/cjs_shims.js"() {
      }
    });
    var require_typeof = __commonJS2({
      "../../node_modules/.pnpm/@babel+runtime@7.18.9/node_modules/@babel/runtime/helpers/typeof.js"(exports2, module22) {
        init_cjs_shims();
        function _typeof2(obj) {
          "@babel/helpers - typeof";
          return module22.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
            return typeof obj2;
          } : function(obj2) {
            return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          }, module22.exports.__esModule = true, module22.exports["default"] = module22.exports, _typeof2(obj);
        }
        module22.exports = _typeof2, module22.exports.__esModule = true, module22.exports["default"] = module22.exports;
      }
    });
    var require_regeneratorRuntime = __commonJS2({
      "../../node_modules/.pnpm/@babel+runtime@7.18.9/node_modules/@babel/runtime/helpers/regeneratorRuntime.js"(exports2, module22) {
        init_cjs_shims();
        var _typeof2 = require_typeof()["default"];
        function _regeneratorRuntime2() {
          "use strict";
          module22.exports = _regeneratorRuntime2 = function _regeneratorRuntime3() {
            return exports22;
          }, module22.exports.__esModule = true, module22.exports["default"] = module22.exports;
          var exports22 = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
          function define(obj, key, value) {
            return Object.defineProperty(obj, key, {
              value,
              enumerable: true,
              configurable: true,
              writable: true
            }), obj[key];
          }
          try {
            define({}, "");
          } catch (err) {
            define = function define2(obj, key, value) {
              return obj[key] = value;
            };
          }
          function wrap(innerFn, outerFn, self, tryLocsList) {
            var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
            return generator._invoke = function(innerFn2, self2, context2) {
              var state = "suspendedStart";
              return function(method, arg) {
                if ("executing" === state)
                  throw new Error("Generator is already running");
                if ("completed" === state) {
                  if ("throw" === method)
                    throw arg;
                  return doneResult();
                }
                for (context2.method = method, context2.arg = arg; ; ) {
                  var delegate = context2.delegate;
                  if (delegate) {
                    var delegateResult = maybeInvokeDelegate(delegate, context2);
                    if (delegateResult) {
                      if (delegateResult === ContinueSentinel)
                        continue;
                      return delegateResult;
                    }
                  }
                  if ("next" === context2.method)
                    context2.sent = context2._sent = context2.arg;
                  else if ("throw" === context2.method) {
                    if ("suspendedStart" === state)
                      throw state = "completed", context2.arg;
                    context2.dispatchException(context2.arg);
                  } else
                    "return" === context2.method && context2.abrupt("return", context2.arg);
                  state = "executing";
                  var record = tryCatch(innerFn2, self2, context2);
                  if ("normal" === record.type) {
                    if (state = context2.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
                      continue;
                    return {
                      value: record.arg,
                      done: context2.done
                    };
                  }
                  "throw" === record.type && (state = "completed", context2.method = "throw", context2.arg = record.arg);
                }
              };
            }(innerFn, self, context), generator;
          }
          function tryCatch(fn, obj, arg) {
            try {
              return {
                type: "normal",
                arg: fn.call(obj, arg)
              };
            } catch (err) {
              return {
                type: "throw",
                arg: err
              };
            }
          }
          exports22.wrap = wrap;
          var ContinueSentinel = {};
          function Generator() {
          }
          function GeneratorFunction() {
          }
          function GeneratorFunctionPrototype() {
          }
          var IteratorPrototype = {};
          define(IteratorPrototype, iteratorSymbol, function() {
            return this;
          });
          var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
          NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
          var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
          function defineIteratorMethods(prototype) {
            ["next", "throw", "return"].forEach(function(method) {
              define(prototype, method, function(arg) {
                return this._invoke(method, arg);
              });
            });
          }
          function AsyncIterator(generator, PromiseImpl) {
            function invoke(method, arg, resolve, reject) {
              var record = tryCatch(generator[method], generator, arg);
              if ("throw" !== record.type) {
                var result = record.arg, value = result.value;
                return value && "object" == _typeof2(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
                  invoke("next", value2, resolve, reject);
                }, function(err) {
                  invoke("throw", err, resolve, reject);
                }) : PromiseImpl.resolve(value).then(function(unwrapped) {
                  result.value = unwrapped, resolve(result);
                }, function(error) {
                  return invoke("throw", error, resolve, reject);
                });
              }
              reject(record.arg);
            }
            var previousPromise;
            this._invoke = function(method, arg) {
              function callInvokeWithMethodAndArg() {
                return new PromiseImpl(function(resolve, reject) {
                  invoke(method, arg, resolve, reject);
                });
              }
              return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
            };
          }
          function maybeInvokeDelegate(delegate, context) {
            var method = delegate.iterator[context.method];
            if (void 0 === method) {
              if (context.delegate = null, "throw" === context.method) {
                if (delegate.iterator["return"] && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method))
                  return ContinueSentinel;
                context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
              }
              return ContinueSentinel;
            }
            var record = tryCatch(method, delegate.iterator, context.arg);
            if ("throw" === record.type)
              return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
            var info = record.arg;
            return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
          }
          function pushTryEntry(locs) {
            var entry = {
              tryLoc: locs[0]
            };
            1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
          }
          function resetTryEntry(entry) {
            var record = entry.completion || {};
            record.type = "normal", delete record.arg, entry.completion = record;
          }
          function Context(tryLocsList) {
            this.tryEntries = [{
              tryLoc: "root"
            }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
          }
          function values(iterable) {
            if (iterable) {
              var iteratorMethod = iterable[iteratorSymbol];
              if (iteratorMethod)
                return iteratorMethod.call(iterable);
              if ("function" == typeof iterable.next)
                return iterable;
              if (!isNaN(iterable.length)) {
                var i = -1, next = function next2() {
                  for (; ++i < iterable.length; ) {
                    if (hasOwn.call(iterable, i))
                      return next2.value = iterable[i], next2.done = false, next2;
                  }
                  return next2.value = void 0, next2.done = true, next2;
                };
                return next.next = next;
              }
            }
            return {
              next: doneResult
            };
          }
          function doneResult() {
            return {
              value: void 0,
              done: true
            };
          }
          return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports22.isGeneratorFunction = function(genFun) {
            var ctor = "function" == typeof genFun && genFun.constructor;
            return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
          }, exports22.mark = function(genFun) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
          }, exports22.awrap = function(arg) {
            return {
              __await: arg
            };
          }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
            return this;
          }), exports22.AsyncIterator = AsyncIterator, exports22.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
            void 0 === PromiseImpl && (PromiseImpl = Promise);
            var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
            return exports22.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
              return result.done ? result.value : iter.next();
            });
          }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function() {
            return this;
          }), define(Gp, "toString", function() {
            return "[object Generator]";
          }), exports22.keys = function(object) {
            var keys = [];
            for (var key in object) {
              keys.push(key);
            }
            return keys.reverse(), function next() {
              for (; keys.length; ) {
                var key2 = keys.pop();
                if (key2 in object)
                  return next.value = key2, next.done = false, next;
              }
              return next.done = true, next;
            };
          }, exports22.values = values, Context.prototype = {
            constructor: Context,
            reset: function reset(skipTempReset) {
              if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
                for (var name in this) {
                  "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
                }
            },
            stop: function stop() {
              this.done = true;
              var rootRecord = this.tryEntries[0].completion;
              if ("throw" === rootRecord.type)
                throw rootRecord.arg;
              return this.rval;
            },
            dispatchException: function dispatchException(exception) {
              if (this.done)
                throw exception;
              var context = this;
              function handle(loc, caught) {
                return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
              }
              for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i], record = entry.completion;
                if ("root" === entry.tryLoc)
                  return handle("end");
                if (entry.tryLoc <= this.prev) {
                  var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
                  if (hasCatch && hasFinally) {
                    if (this.prev < entry.catchLoc)
                      return handle(entry.catchLoc, true);
                    if (this.prev < entry.finallyLoc)
                      return handle(entry.finallyLoc);
                  } else if (hasCatch) {
                    if (this.prev < entry.catchLoc)
                      return handle(entry.catchLoc, true);
                  } else {
                    if (!hasFinally)
                      throw new Error("try statement without catch or finally");
                    if (this.prev < entry.finallyLoc)
                      return handle(entry.finallyLoc);
                  }
                }
              }
            },
            abrupt: function abrupt(type, arg) {
              for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                  var finallyEntry = entry;
                  break;
                }
              }
              finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
              var record = finallyEntry ? finallyEntry.completion : {};
              return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
            },
            complete: function complete(record, afterLoc) {
              if ("throw" === record.type)
                throw record.arg;
              return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
            },
            finish: function finish(finallyLoc) {
              for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                if (entry.finallyLoc === finallyLoc)
                  return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
              }
            },
            "catch": function _catch(tryLoc) {
              for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                if (entry.tryLoc === tryLoc) {
                  var record = entry.completion;
                  if ("throw" === record.type) {
                    var thrown = record.arg;
                    resetTryEntry(entry);
                  }
                  return thrown;
                }
              }
              throw new Error("illegal catch attempt");
            },
            delegateYield: function delegateYield(iterable, resultName, nextLoc) {
              return this.delegate = {
                iterator: values(iterable),
                resultName,
                nextLoc
              }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
            }
          }, exports22;
        }
        module22.exports = _regeneratorRuntime2, module22.exports.__esModule = true, module22.exports["default"] = module22.exports;
      }
    });
    var require_regenerator = __commonJS2({
      "../../node_modules/.pnpm/@babel+runtime@7.18.9/node_modules/@babel/runtime/regenerator/index.js"(exports2, module22) {
        init_cjs_shims();
        var runtime = require_regeneratorRuntime()();
        module22.exports = runtime;
        try {
          regeneratorRuntime = runtime;
        } catch (accidentalStrictMode) {
          if (typeof globalThis === "object") {
            globalThis.regeneratorRuntime = runtime;
          } else {
            Function("r", "regeneratorRuntime = r")(runtime);
          }
        }
      }
    });
    var require_p_try = __commonJS2({
      "../../node_modules/.pnpm/p-try@2.2.0/node_modules/p-try/index.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var pTry = (fn, ...arguments_) => new Promise((resolve) => {
          resolve(fn(...arguments_));
        });
        module22.exports = pTry;
        module22.exports.default = pTry;
      }
    });
    var require_p_limit = __commonJS2({
      "../../node_modules/.pnpm/p-limit@2.3.0/node_modules/p-limit/index.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var pTry = require_p_try();
        var pLimit = (concurrency) => {
          if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
            return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));
          }
          const queue = [];
          let activeCount = 0;
          const next = () => {
            activeCount--;
            if (queue.length > 0) {
              queue.shift()();
            }
          };
          const run = (fn, resolve, ...args) => {
            activeCount++;
            const result = pTry(fn, ...args);
            resolve(result);
            result.then(next, next);
          };
          const enqueue = (fn, resolve, ...args) => {
            if (activeCount < concurrency) {
              run(fn, resolve, ...args);
            } else {
              queue.push(run.bind(null, fn, resolve, ...args));
            }
          };
          const generator = (fn, ...args) => new Promise((resolve) => enqueue(fn, resolve, ...args));
          Object.defineProperties(generator, {
            activeCount: {
              get: () => activeCount
            },
            pendingCount: {
              get: () => queue.length
            },
            clearQueue: {
              value: () => {
                queue.length = 0;
              }
            }
          });
          return generator;
        };
        module22.exports = pLimit;
        module22.exports.default = pLimit;
      }
    });
    var require_p_locate = __commonJS2({
      "../../node_modules/.pnpm/p-locate@4.1.0/node_modules/p-locate/index.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var pLimit = require_p_limit();
        var EndError = class extends Error {
          constructor(value) {
            super();
            this.value = value;
          }
        };
        var testElement = async (element, tester) => tester(await element);
        var finder = async (element) => {
          const values = await Promise.all(element);
          if (values[1] === true) {
            throw new EndError(values[0]);
          }
          return false;
        };
        var pLocate = async (iterable, tester, options) => {
          options = {
            concurrency: Infinity,
            preserveOrder: true,
            ...options
          };
          const limit = pLimit(options.concurrency);
          const items = [...iterable].map((element) => [element, limit(testElement, element, tester)]);
          const checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);
          try {
            await Promise.all(items.map((element) => checkLimit(finder, element)));
          } catch (error) {
            if (error instanceof EndError) {
              return error.value;
            }
            throw error;
          }
        };
        module22.exports = pLocate;
        module22.exports.default = pLocate;
      }
    });
    var require_locate_path = __commonJS2({
      "../../node_modules/.pnpm/locate-path@5.0.0/node_modules/locate-path/index.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var path4 = require("path");
        var fs4 = require("fs");
        var { promisify } = require("util");
        var pLocate = require_p_locate();
        var fsStat = promisify(fs4.stat);
        var fsLStat = promisify(fs4.lstat);
        var typeMappings = {
          directory: "isDirectory",
          file: "isFile"
        };
        function checkType({ type }) {
          if (type in typeMappings) {
            return;
          }
          throw new Error(`Invalid type specified: ${type}`);
        }
        var matchType = (type, stat) => type === void 0 || stat[typeMappings[type]]();
        module22.exports = async (paths, options) => {
          options = {
            cwd: process.cwd(),
            type: "file",
            allowSymlinks: true,
            ...options
          };
          checkType(options);
          const statFn = options.allowSymlinks ? fsStat : fsLStat;
          return pLocate(paths, async (path_) => {
            try {
              const stat = await statFn(path4.resolve(options.cwd, path_));
              return matchType(options.type, stat);
            } catch (_) {
              return false;
            }
          }, options);
        };
        module22.exports.sync = (paths, options) => {
          options = {
            cwd: process.cwd(),
            allowSymlinks: true,
            type: "file",
            ...options
          };
          checkType(options);
          const statFn = options.allowSymlinks ? fs4.statSync : fs4.lstatSync;
          for (const path_ of paths) {
            try {
              const stat = statFn(path4.resolve(options.cwd, path_));
              if (matchType(options.type, stat)) {
                return path_;
              }
            } catch (_) {
            }
          }
        };
      }
    });
    var require_path_exists = __commonJS2({
      "../../node_modules/.pnpm/path-exists@4.0.0/node_modules/path-exists/index.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var fs4 = require("fs");
        var { promisify } = require("util");
        var pAccess = promisify(fs4.access);
        module22.exports = async (path4) => {
          try {
            await pAccess(path4);
            return true;
          } catch (_) {
            return false;
          }
        };
        module22.exports.sync = (path4) => {
          try {
            fs4.accessSync(path4);
            return true;
          } catch (_) {
            return false;
          }
        };
      }
    });
    var require_find_up = __commonJS2({
      "../../node_modules/.pnpm/find-up@4.1.0/node_modules/find-up/index.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var path4 = require("path");
        var locatePath = require_locate_path();
        var pathExists = require_path_exists();
        var stop = Symbol("findUp.stop");
        module22.exports = async (name, options = {}) => {
          let directory = path4.resolve(options.cwd || "");
          const { root } = path4.parse(directory);
          const paths = [].concat(name);
          const runMatcher = async (locateOptions) => {
            if (typeof name !== "function") {
              return locatePath(paths, locateOptions);
            }
            const foundPath = await name(locateOptions.cwd);
            if (typeof foundPath === "string") {
              return locatePath([foundPath], locateOptions);
            }
            return foundPath;
          };
          while (true) {
            const foundPath = await runMatcher({ ...options, cwd: directory });
            if (foundPath === stop) {
              return;
            }
            if (foundPath) {
              return path4.resolve(directory, foundPath);
            }
            if (directory === root) {
              return;
            }
            directory = path4.dirname(directory);
          }
        };
        module22.exports.sync = (name, options = {}) => {
          let directory = path4.resolve(options.cwd || "");
          const { root } = path4.parse(directory);
          const paths = [].concat(name);
          const runMatcher = (locateOptions) => {
            if (typeof name !== "function") {
              return locatePath.sync(paths, locateOptions);
            }
            const foundPath = name(locateOptions.cwd);
            if (typeof foundPath === "string") {
              return locatePath.sync([foundPath], locateOptions);
            }
            return foundPath;
          };
          while (true) {
            const foundPath = runMatcher({ ...options, cwd: directory });
            if (foundPath === stop) {
              return;
            }
            if (foundPath) {
              return path4.resolve(directory, foundPath);
            }
            if (directory === root) {
              return;
            }
            directory = path4.dirname(directory);
          }
        };
        module22.exports.exists = pathExists;
        module22.exports.sync.exists = pathExists.sync;
        module22.exports.stop = stop;
      }
    });
    var require_universalify = __commonJS2({
      "../../node_modules/.pnpm/universalify@0.1.2/node_modules/universalify/index.js"(exports2) {
        "use strict";
        init_cjs_shims();
        exports2.fromCallback = function(fn) {
          return Object.defineProperty(function() {
            if (typeof arguments[arguments.length - 1] === "function")
              fn.apply(this, arguments);
            else {
              return new Promise((resolve, reject) => {
                arguments[arguments.length] = (err, res) => {
                  if (err)
                    return reject(err);
                  resolve(res);
                };
                arguments.length++;
                fn.apply(this, arguments);
              });
            }
          }, "name", { value: fn.name });
        };
        exports2.fromPromise = function(fn) {
          return Object.defineProperty(function() {
            const cb = arguments[arguments.length - 1];
            if (typeof cb !== "function")
              return fn.apply(this, arguments);
            else
              fn.apply(this, arguments).then((r) => cb(null, r), cb);
          }, "name", { value: fn.name });
        };
      }
    });
    var require_polyfills = __commonJS2({
      "../../node_modules/.pnpm/graceful-fs@4.2.10/node_modules/graceful-fs/polyfills.js"(exports2, module22) {
        init_cjs_shims();
        var constants = require("constants");
        var origCwd = process.cwd;
        var cwd = null;
        var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
        process.cwd = function() {
          if (!cwd)
            cwd = origCwd.call(process);
          return cwd;
        };
        try {
          process.cwd();
        } catch (er) {
        }
        if (typeof process.chdir === "function") {
          chdir = process.chdir;
          process.chdir = function(d) {
            cwd = null;
            chdir.call(process, d);
          };
          if (Object.setPrototypeOf)
            Object.setPrototypeOf(process.chdir, chdir);
        }
        var chdir;
        module22.exports = patch;
        function patch(fs4) {
          if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
            patchLchmod(fs4);
          }
          if (!fs4.lutimes) {
            patchLutimes(fs4);
          }
          fs4.chown = chownFix(fs4.chown);
          fs4.fchown = chownFix(fs4.fchown);
          fs4.lchown = chownFix(fs4.lchown);
          fs4.chmod = chmodFix(fs4.chmod);
          fs4.fchmod = chmodFix(fs4.fchmod);
          fs4.lchmod = chmodFix(fs4.lchmod);
          fs4.chownSync = chownFixSync(fs4.chownSync);
          fs4.fchownSync = chownFixSync(fs4.fchownSync);
          fs4.lchownSync = chownFixSync(fs4.lchownSync);
          fs4.chmodSync = chmodFixSync(fs4.chmodSync);
          fs4.fchmodSync = chmodFixSync(fs4.fchmodSync);
          fs4.lchmodSync = chmodFixSync(fs4.lchmodSync);
          fs4.stat = statFix(fs4.stat);
          fs4.fstat = statFix(fs4.fstat);
          fs4.lstat = statFix(fs4.lstat);
          fs4.statSync = statFixSync(fs4.statSync);
          fs4.fstatSync = statFixSync(fs4.fstatSync);
          fs4.lstatSync = statFixSync(fs4.lstatSync);
          if (fs4.chmod && !fs4.lchmod) {
            fs4.lchmod = function(path4, mode, cb) {
              if (cb)
                process.nextTick(cb);
            };
            fs4.lchmodSync = function() {
            };
          }
          if (fs4.chown && !fs4.lchown) {
            fs4.lchown = function(path4, uid, gid, cb) {
              if (cb)
                process.nextTick(cb);
            };
            fs4.lchownSync = function() {
            };
          }
          if (platform === "win32") {
            fs4.rename = typeof fs4.rename !== "function" ? fs4.rename : function(fs$rename) {
              function rename(from, to, cb) {
                var start = Date.now();
                var backoff = 0;
                fs$rename(from, to, function CB(er) {
                  if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
                    setTimeout(function() {
                      fs4.stat(to, function(stater, st) {
                        if (stater && stater.code === "ENOENT")
                          fs$rename(from, to, CB);
                        else
                          cb(er);
                      });
                    }, backoff);
                    if (backoff < 100)
                      backoff += 10;
                    return;
                  }
                  if (cb)
                    cb(er);
                });
              }
              if (Object.setPrototypeOf)
                Object.setPrototypeOf(rename, fs$rename);
              return rename;
            }(fs4.rename);
          }
          fs4.read = typeof fs4.read !== "function" ? fs4.read : function(fs$read) {
            function read(fd, buffer, offset, length, position, callback_) {
              var callback;
              if (callback_ && typeof callback_ === "function") {
                var eagCounter = 0;
                callback = function(er, _, __) {
                  if (er && er.code === "EAGAIN" && eagCounter < 10) {
                    eagCounter++;
                    return fs$read.call(fs4, fd, buffer, offset, length, position, callback);
                  }
                  callback_.apply(this, arguments);
                };
              }
              return fs$read.call(fs4, fd, buffer, offset, length, position, callback);
            }
            if (Object.setPrototypeOf)
              Object.setPrototypeOf(read, fs$read);
            return read;
          }(fs4.read);
          fs4.readSync = typeof fs4.readSync !== "function" ? fs4.readSync : function(fs$readSync) {
            return function(fd, buffer, offset, length, position) {
              var eagCounter = 0;
              while (true) {
                try {
                  return fs$readSync.call(fs4, fd, buffer, offset, length, position);
                } catch (er) {
                  if (er.code === "EAGAIN" && eagCounter < 10) {
                    eagCounter++;
                    continue;
                  }
                  throw er;
                }
              }
            };
          }(fs4.readSync);
          function patchLchmod(fs5) {
            fs5.lchmod = function(path4, mode, callback) {
              fs5.open(
                path4,
                constants.O_WRONLY | constants.O_SYMLINK,
                mode,
                function(err, fd) {
                  if (err) {
                    if (callback)
                      callback(err);
                    return;
                  }
                  fs5.fchmod(fd, mode, function(err2) {
                    fs5.close(fd, function(err22) {
                      if (callback)
                        callback(err2 || err22);
                    });
                  });
                }
              );
            };
            fs5.lchmodSync = function(path4, mode) {
              var fd = fs5.openSync(path4, constants.O_WRONLY | constants.O_SYMLINK, mode);
              var threw = true;
              var ret;
              try {
                ret = fs5.fchmodSync(fd, mode);
                threw = false;
              } finally {
                if (threw) {
                  try {
                    fs5.closeSync(fd);
                  } catch (er) {
                  }
                } else {
                  fs5.closeSync(fd);
                }
              }
              return ret;
            };
          }
          function patchLutimes(fs5) {
            if (constants.hasOwnProperty("O_SYMLINK") && fs5.futimes) {
              fs5.lutimes = function(path4, at, mt, cb) {
                fs5.open(path4, constants.O_SYMLINK, function(er, fd) {
                  if (er) {
                    if (cb)
                      cb(er);
                    return;
                  }
                  fs5.futimes(fd, at, mt, function(er2) {
                    fs5.close(fd, function(er22) {
                      if (cb)
                        cb(er2 || er22);
                    });
                  });
                });
              };
              fs5.lutimesSync = function(path4, at, mt) {
                var fd = fs5.openSync(path4, constants.O_SYMLINK);
                var ret;
                var threw = true;
                try {
                  ret = fs5.futimesSync(fd, at, mt);
                  threw = false;
                } finally {
                  if (threw) {
                    try {
                      fs5.closeSync(fd);
                    } catch (er) {
                    }
                  } else {
                    fs5.closeSync(fd);
                  }
                }
                return ret;
              };
            } else if (fs5.futimes) {
              fs5.lutimes = function(_a, _b, _c, cb) {
                if (cb)
                  process.nextTick(cb);
              };
              fs5.lutimesSync = function() {
              };
            }
          }
          function chmodFix(orig) {
            if (!orig)
              return orig;
            return function(target, mode, cb) {
              return orig.call(fs4, target, mode, function(er) {
                if (chownErOk(er))
                  er = null;
                if (cb)
                  cb.apply(this, arguments);
              });
            };
          }
          function chmodFixSync(orig) {
            if (!orig)
              return orig;
            return function(target, mode) {
              try {
                return orig.call(fs4, target, mode);
              } catch (er) {
                if (!chownErOk(er))
                  throw er;
              }
            };
          }
          function chownFix(orig) {
            if (!orig)
              return orig;
            return function(target, uid, gid, cb) {
              return orig.call(fs4, target, uid, gid, function(er) {
                if (chownErOk(er))
                  er = null;
                if (cb)
                  cb.apply(this, arguments);
              });
            };
          }
          function chownFixSync(orig) {
            if (!orig)
              return orig;
            return function(target, uid, gid) {
              try {
                return orig.call(fs4, target, uid, gid);
              } catch (er) {
                if (!chownErOk(er))
                  throw er;
              }
            };
          }
          function statFix(orig) {
            if (!orig)
              return orig;
            return function(target, options, cb) {
              if (typeof options === "function") {
                cb = options;
                options = null;
              }
              function callback(er, stats) {
                if (stats) {
                  if (stats.uid < 0)
                    stats.uid += 4294967296;
                  if (stats.gid < 0)
                    stats.gid += 4294967296;
                }
                if (cb)
                  cb.apply(this, arguments);
              }
              return options ? orig.call(fs4, target, options, callback) : orig.call(fs4, target, callback);
            };
          }
          function statFixSync(orig) {
            if (!orig)
              return orig;
            return function(target, options) {
              var stats = options ? orig.call(fs4, target, options) : orig.call(fs4, target);
              if (stats) {
                if (stats.uid < 0)
                  stats.uid += 4294967296;
                if (stats.gid < 0)
                  stats.gid += 4294967296;
              }
              return stats;
            };
          }
          function chownErOk(er) {
            if (!er)
              return true;
            if (er.code === "ENOSYS")
              return true;
            var nonroot = !process.getuid || process.getuid() !== 0;
            if (nonroot) {
              if (er.code === "EINVAL" || er.code === "EPERM")
                return true;
            }
            return false;
          }
        }
      }
    });
    var require_legacy_streams = __commonJS2({
      "../../node_modules/.pnpm/graceful-fs@4.2.10/node_modules/graceful-fs/legacy-streams.js"(exports2, module22) {
        init_cjs_shims();
        var Stream = require("stream").Stream;
        module22.exports = legacy;
        function legacy(fs4) {
          return {
            ReadStream,
            WriteStream
          };
          function ReadStream(path4, options) {
            if (!(this instanceof ReadStream))
              return new ReadStream(path4, options);
            Stream.call(this);
            var self = this;
            this.path = path4;
            this.fd = null;
            this.readable = true;
            this.paused = false;
            this.flags = "r";
            this.mode = 438;
            this.bufferSize = 64 * 1024;
            options = options || {};
            var keys = Object.keys(options);
            for (var index = 0, length = keys.length; index < length; index++) {
              var key = keys[index];
              this[key] = options[key];
            }
            if (this.encoding)
              this.setEncoding(this.encoding);
            if (this.start !== void 0) {
              if ("number" !== typeof this.start) {
                throw TypeError("start must be a Number");
              }
              if (this.end === void 0) {
                this.end = Infinity;
              } else if ("number" !== typeof this.end) {
                throw TypeError("end must be a Number");
              }
              if (this.start > this.end) {
                throw new Error("start must be <= end");
              }
              this.pos = this.start;
            }
            if (this.fd !== null) {
              process.nextTick(function() {
                self._read();
              });
              return;
            }
            fs4.open(this.path, this.flags, this.mode, function(err, fd) {
              if (err) {
                self.emit("error", err);
                self.readable = false;
                return;
              }
              self.fd = fd;
              self.emit("open", fd);
              self._read();
            });
          }
          function WriteStream(path4, options) {
            if (!(this instanceof WriteStream))
              return new WriteStream(path4, options);
            Stream.call(this);
            this.path = path4;
            this.fd = null;
            this.writable = true;
            this.flags = "w";
            this.encoding = "binary";
            this.mode = 438;
            this.bytesWritten = 0;
            options = options || {};
            var keys = Object.keys(options);
            for (var index = 0, length = keys.length; index < length; index++) {
              var key = keys[index];
              this[key] = options[key];
            }
            if (this.start !== void 0) {
              if ("number" !== typeof this.start) {
                throw TypeError("start must be a Number");
              }
              if (this.start < 0) {
                throw new Error("start must be >= zero");
              }
              this.pos = this.start;
            }
            this.busy = false;
            this._queue = [];
            if (this.fd === null) {
              this._open = fs4.open;
              this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
              this.flush();
            }
          }
        }
      }
    });
    var require_clone = __commonJS2({
      "../../node_modules/.pnpm/graceful-fs@4.2.10/node_modules/graceful-fs/clone.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        module22.exports = clone;
        var getPrototypeOf = Object.getPrototypeOf || function(obj) {
          return obj.__proto__;
        };
        function clone(obj) {
          if (obj === null || typeof obj !== "object")
            return obj;
          if (obj instanceof Object)
            var copy = { __proto__: getPrototypeOf(obj) };
          else
            var copy = /* @__PURE__ */ Object.create(null);
          Object.getOwnPropertyNames(obj).forEach(function(key) {
            Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
          });
          return copy;
        }
      }
    });
    var require_graceful_fs = __commonJS2({
      "../../node_modules/.pnpm/graceful-fs@4.2.10/node_modules/graceful-fs/graceful-fs.js"(exports2, module22) {
        init_cjs_shims();
        var fs4 = require("fs");
        var polyfills = require_polyfills();
        var legacy = require_legacy_streams();
        var clone = require_clone();
        var util = require("util");
        var gracefulQueue;
        var previousSymbol;
        if (typeof Symbol === "function" && typeof Symbol.for === "function") {
          gracefulQueue = Symbol.for("graceful-fs.queue");
          previousSymbol = Symbol.for("graceful-fs.previous");
        } else {
          gracefulQueue = "___graceful-fs.queue";
          previousSymbol = "___graceful-fs.previous";
        }
        function noop() {
        }
        function publishQueue(context, queue2) {
          Object.defineProperty(context, gracefulQueue, {
            get: function() {
              return queue2;
            }
          });
        }
        var debug = noop;
        if (util.debuglog)
          debug = util.debuglog("gfs4");
        else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
          debug = function() {
            var m = util.format.apply(util, arguments);
            m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
            console.error(m);
          };
        if (!fs4[gracefulQueue]) {
          queue = global[gracefulQueue] || [];
          publishQueue(fs4, queue);
          fs4.close = function(fs$close) {
            function close(fd, cb) {
              return fs$close.call(fs4, fd, function(err) {
                if (!err) {
                  resetQueue();
                }
                if (typeof cb === "function")
                  cb.apply(this, arguments);
              });
            }
            Object.defineProperty(close, previousSymbol, {
              value: fs$close
            });
            return close;
          }(fs4.close);
          fs4.closeSync = function(fs$closeSync) {
            function closeSync(fd) {
              fs$closeSync.apply(fs4, arguments);
              resetQueue();
            }
            Object.defineProperty(closeSync, previousSymbol, {
              value: fs$closeSync
            });
            return closeSync;
          }(fs4.closeSync);
          if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
            process.on("exit", function() {
              debug(fs4[gracefulQueue]);
              require("assert").equal(fs4[gracefulQueue].length, 0);
            });
          }
        }
        var queue;
        if (!global[gracefulQueue]) {
          publishQueue(global, fs4[gracefulQueue]);
        }
        module22.exports = patch(clone(fs4));
        if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs4.__patched) {
          module22.exports = patch(fs4);
          fs4.__patched = true;
        }
        function patch(fs5) {
          polyfills(fs5);
          fs5.gracefulify = patch;
          fs5.createReadStream = createReadStream;
          fs5.createWriteStream = createWriteStream;
          var fs$readFile = fs5.readFile;
          fs5.readFile = readFile;
          function readFile(path4, options, cb) {
            if (typeof options === "function")
              cb = options, options = null;
            return go$readFile(path4, options, cb);
            function go$readFile(path5, options2, cb2, startTime) {
              return fs$readFile(path5, options2, function(err) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
                  enqueue([go$readFile, [path5, options2, cb2], err, startTime || Date.now(), Date.now()]);
                else {
                  if (typeof cb2 === "function")
                    cb2.apply(this, arguments);
                }
              });
            }
          }
          var fs$writeFile = fs5.writeFile;
          fs5.writeFile = writeFile;
          function writeFile(path4, data, options, cb) {
            if (typeof options === "function")
              cb = options, options = null;
            return go$writeFile(path4, data, options, cb);
            function go$writeFile(path5, data2, options2, cb2, startTime) {
              return fs$writeFile(path5, data2, options2, function(err) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
                  enqueue([go$writeFile, [path5, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
                else {
                  if (typeof cb2 === "function")
                    cb2.apply(this, arguments);
                }
              });
            }
          }
          var fs$appendFile = fs5.appendFile;
          if (fs$appendFile)
            fs5.appendFile = appendFile;
          function appendFile(path4, data, options, cb) {
            if (typeof options === "function")
              cb = options, options = null;
            return go$appendFile(path4, data, options, cb);
            function go$appendFile(path5, data2, options2, cb2, startTime) {
              return fs$appendFile(path5, data2, options2, function(err) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
                  enqueue([go$appendFile, [path5, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
                else {
                  if (typeof cb2 === "function")
                    cb2.apply(this, arguments);
                }
              });
            }
          }
          var fs$copyFile = fs5.copyFile;
          if (fs$copyFile)
            fs5.copyFile = copyFile;
          function copyFile(src, dest, flags, cb) {
            if (typeof flags === "function") {
              cb = flags;
              flags = 0;
            }
            return go$copyFile(src, dest, flags, cb);
            function go$copyFile(src2, dest2, flags2, cb2, startTime) {
              return fs$copyFile(src2, dest2, flags2, function(err) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
                  enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
                else {
                  if (typeof cb2 === "function")
                    cb2.apply(this, arguments);
                }
              });
            }
          }
          var fs$readdir = fs5.readdir;
          fs5.readdir = readdir;
          var noReaddirOptionVersions = /^v[0-5]\./;
          function readdir(path4, options, cb) {
            if (typeof options === "function")
              cb = options, options = null;
            var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path5, options2, cb2, startTime) {
              return fs$readdir(path5, fs$readdirCallback(
                path5,
                options2,
                cb2,
                startTime
              ));
            } : function go$readdir2(path5, options2, cb2, startTime) {
              return fs$readdir(path5, options2, fs$readdirCallback(
                path5,
                options2,
                cb2,
                startTime
              ));
            };
            return go$readdir(path4, options, cb);
            function fs$readdirCallback(path5, options2, cb2, startTime) {
              return function(err, files) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
                  enqueue([
                    go$readdir,
                    [path5, options2, cb2],
                    err,
                    startTime || Date.now(),
                    Date.now()
                  ]);
                else {
                  if (files && files.sort)
                    files.sort();
                  if (typeof cb2 === "function")
                    cb2.call(this, err, files);
                }
              };
            }
          }
          if (process.version.substr(0, 4) === "v0.8") {
            var legStreams = legacy(fs5);
            ReadStream = legStreams.ReadStream;
            WriteStream = legStreams.WriteStream;
          }
          var fs$ReadStream = fs5.ReadStream;
          if (fs$ReadStream) {
            ReadStream.prototype = Object.create(fs$ReadStream.prototype);
            ReadStream.prototype.open = ReadStream$open;
          }
          var fs$WriteStream = fs5.WriteStream;
          if (fs$WriteStream) {
            WriteStream.prototype = Object.create(fs$WriteStream.prototype);
            WriteStream.prototype.open = WriteStream$open;
          }
          Object.defineProperty(fs5, "ReadStream", {
            get: function() {
              return ReadStream;
            },
            set: function(val) {
              ReadStream = val;
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(fs5, "WriteStream", {
            get: function() {
              return WriteStream;
            },
            set: function(val) {
              WriteStream = val;
            },
            enumerable: true,
            configurable: true
          });
          var FileReadStream = ReadStream;
          Object.defineProperty(fs5, "FileReadStream", {
            get: function() {
              return FileReadStream;
            },
            set: function(val) {
              FileReadStream = val;
            },
            enumerable: true,
            configurable: true
          });
          var FileWriteStream = WriteStream;
          Object.defineProperty(fs5, "FileWriteStream", {
            get: function() {
              return FileWriteStream;
            },
            set: function(val) {
              FileWriteStream = val;
            },
            enumerable: true,
            configurable: true
          });
          function ReadStream(path4, options) {
            if (this instanceof ReadStream)
              return fs$ReadStream.apply(this, arguments), this;
            else
              return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
          }
          function ReadStream$open() {
            var that = this;
            open(that.path, that.flags, that.mode, function(err, fd) {
              if (err) {
                if (that.autoClose)
                  that.destroy();
                that.emit("error", err);
              } else {
                that.fd = fd;
                that.emit("open", fd);
                that.read();
              }
            });
          }
          function WriteStream(path4, options) {
            if (this instanceof WriteStream)
              return fs$WriteStream.apply(this, arguments), this;
            else
              return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
          }
          function WriteStream$open() {
            var that = this;
            open(that.path, that.flags, that.mode, function(err, fd) {
              if (err) {
                that.destroy();
                that.emit("error", err);
              } else {
                that.fd = fd;
                that.emit("open", fd);
              }
            });
          }
          function createReadStream(path4, options) {
            return new fs5.ReadStream(path4, options);
          }
          function createWriteStream(path4, options) {
            return new fs5.WriteStream(path4, options);
          }
          var fs$open = fs5.open;
          fs5.open = open;
          function open(path4, flags, mode, cb) {
            if (typeof mode === "function")
              cb = mode, mode = null;
            return go$open(path4, flags, mode, cb);
            function go$open(path5, flags2, mode2, cb2, startTime) {
              return fs$open(path5, flags2, mode2, function(err, fd) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
                  enqueue([go$open, [path5, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
                else {
                  if (typeof cb2 === "function")
                    cb2.apply(this, arguments);
                }
              });
            }
          }
          return fs5;
        }
        function enqueue(elem) {
          debug("ENQUEUE", elem[0].name, elem[1]);
          fs4[gracefulQueue].push(elem);
          retry();
        }
        var retryTimer;
        function resetQueue() {
          var now = Date.now();
          for (var i = 0; i < fs4[gracefulQueue].length; ++i) {
            if (fs4[gracefulQueue][i].length > 2) {
              fs4[gracefulQueue][i][3] = now;
              fs4[gracefulQueue][i][4] = now;
            }
          }
          retry();
        }
        function retry() {
          clearTimeout(retryTimer);
          retryTimer = void 0;
          if (fs4[gracefulQueue].length === 0)
            return;
          var elem = fs4[gracefulQueue].shift();
          var fn = elem[0];
          var args = elem[1];
          var err = elem[2];
          var startTime = elem[3];
          var lastTime = elem[4];
          if (startTime === void 0) {
            debug("RETRY", fn.name, args);
            fn.apply(null, args);
          } else if (Date.now() - startTime >= 6e4) {
            debug("TIMEOUT", fn.name, args);
            var cb = args.pop();
            if (typeof cb === "function")
              cb.call(null, err);
          } else {
            var sinceAttempt = Date.now() - lastTime;
            var sinceStart = Math.max(lastTime - startTime, 1);
            var desiredDelay = Math.min(sinceStart * 1.2, 100);
            if (sinceAttempt >= desiredDelay) {
              debug("RETRY", fn.name, args);
              fn.apply(null, args.concat([startTime]));
            } else {
              fs4[gracefulQueue].push(elem);
            }
          }
          if (retryTimer === void 0) {
            retryTimer = setTimeout(retry, 0);
          }
        }
      }
    });
    var require_fs = __commonJS2({
      "../../node_modules/.pnpm/fs-extra@8.1.0/node_modules/fs-extra/lib/fs/index.js"(exports2) {
        "use strict";
        init_cjs_shims();
        var u = require_universalify().fromCallback;
        var fs4 = require_graceful_fs();
        var api = [
          "access",
          "appendFile",
          "chmod",
          "chown",
          "close",
          "copyFile",
          "fchmod",
          "fchown",
          "fdatasync",
          "fstat",
          "fsync",
          "ftruncate",
          "futimes",
          "lchown",
          "lchmod",
          "link",
          "lstat",
          "mkdir",
          "mkdtemp",
          "open",
          "readFile",
          "readdir",
          "readlink",
          "realpath",
          "rename",
          "rmdir",
          "stat",
          "symlink",
          "truncate",
          "unlink",
          "utimes",
          "writeFile"
        ].filter((key) => {
          return typeof fs4[key] === "function";
        });
        Object.keys(fs4).forEach((key) => {
          if (key === "promises") {
            return;
          }
          exports2[key] = fs4[key];
        });
        api.forEach((method) => {
          exports2[method] = u(fs4[method]);
        });
        exports2.exists = function(filename, callback) {
          if (typeof callback === "function") {
            return fs4.exists(filename, callback);
          }
          return new Promise((resolve) => {
            return fs4.exists(filename, resolve);
          });
        };
        exports2.read = function(fd, buffer, offset, length, position, callback) {
          if (typeof callback === "function") {
            return fs4.read(fd, buffer, offset, length, position, callback);
          }
          return new Promise((resolve, reject) => {
            fs4.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
              if (err)
                return reject(err);
              resolve({ bytesRead, buffer: buffer2 });
            });
          });
        };
        exports2.write = function(fd, buffer, ...args) {
          if (typeof args[args.length - 1] === "function") {
            return fs4.write(fd, buffer, ...args);
          }
          return new Promise((resolve, reject) => {
            fs4.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
              if (err)
                return reject(err);
              resolve({ bytesWritten, buffer: buffer2 });
            });
          });
        };
        if (typeof fs4.realpath.native === "function") {
          exports2.realpath.native = u(fs4.realpath.native);
        }
      }
    });
    var require_win32 = __commonJS2({
      "../../node_modules/.pnpm/fs-extra@8.1.0/node_modules/fs-extra/lib/mkdirs/win32.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var path4 = require("path");
        function getRootPath(p) {
          p = path4.normalize(path4.resolve(p)).split(path4.sep);
          if (p.length > 0)
            return p[0];
          return null;
        }
        var INVALID_PATH_CHARS = /[<>:"|?*]/;
        function invalidWin32Path(p) {
          const rp = getRootPath(p);
          p = p.replace(rp, "");
          return INVALID_PATH_CHARS.test(p);
        }
        module22.exports = {
          getRootPath,
          invalidWin32Path
        };
      }
    });
    var require_mkdirs = __commonJS2({
      "../../node_modules/.pnpm/fs-extra@8.1.0/node_modules/fs-extra/lib/mkdirs/mkdirs.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var fs4 = require_graceful_fs();
        var path4 = require("path");
        var invalidWin32Path = require_win32().invalidWin32Path;
        var o777 = parseInt("0777", 8);
        function mkdirs(p, opts, callback, made) {
          if (typeof opts === "function") {
            callback = opts;
            opts = {};
          } else if (!opts || typeof opts !== "object") {
            opts = { mode: opts };
          }
          if (process.platform === "win32" && invalidWin32Path(p)) {
            const errInval = new Error(p + " contains invalid WIN32 path characters.");
            errInval.code = "EINVAL";
            return callback(errInval);
          }
          let mode = opts.mode;
          const xfs = opts.fs || fs4;
          if (mode === void 0) {
            mode = o777 & ~process.umask();
          }
          if (!made)
            made = null;
          callback = callback || function() {
          };
          p = path4.resolve(p);
          xfs.mkdir(p, mode, (er) => {
            if (!er) {
              made = made || p;
              return callback(null, made);
            }
            switch (er.code) {
              case "ENOENT":
                if (path4.dirname(p) === p)
                  return callback(er);
                mkdirs(path4.dirname(p), opts, (er2, made2) => {
                  if (er2)
                    callback(er2, made2);
                  else
                    mkdirs(p, opts, callback, made2);
                });
                break;
              default:
                xfs.stat(p, (er2, stat) => {
                  if (er2 || !stat.isDirectory())
                    callback(er, made);
                  else
                    callback(null, made);
                });
                break;
            }
          });
        }
        module22.exports = mkdirs;
      }
    });
    var require_mkdirs_sync = __commonJS2({
      "../../node_modules/.pnpm/fs-extra@8.1.0/node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var fs4 = require_graceful_fs();
        var path4 = require("path");
        var invalidWin32Path = require_win32().invalidWin32Path;
        var o777 = parseInt("0777", 8);
        function mkdirsSync(p, opts, made) {
          if (!opts || typeof opts !== "object") {
            opts = { mode: opts };
          }
          let mode = opts.mode;
          const xfs = opts.fs || fs4;
          if (process.platform === "win32" && invalidWin32Path(p)) {
            const errInval = new Error(p + " contains invalid WIN32 path characters.");
            errInval.code = "EINVAL";
            throw errInval;
          }
          if (mode === void 0) {
            mode = o777 & ~process.umask();
          }
          if (!made)
            made = null;
          p = path4.resolve(p);
          try {
            xfs.mkdirSync(p, mode);
            made = made || p;
          } catch (err0) {
            if (err0.code === "ENOENT") {
              if (path4.dirname(p) === p)
                throw err0;
              made = mkdirsSync(path4.dirname(p), opts, made);
              mkdirsSync(p, opts, made);
            } else {
              let stat;
              try {
                stat = xfs.statSync(p);
              } catch (err1) {
                throw err0;
              }
              if (!stat.isDirectory())
                throw err0;
            }
          }
          return made;
        }
        module22.exports = mkdirsSync;
      }
    });
    var require_mkdirs2 = __commonJS2({
      "../../node_modules/.pnpm/fs-extra@8.1.0/node_modules/fs-extra/lib/mkdirs/index.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var u = require_universalify().fromCallback;
        var mkdirs = u(require_mkdirs());
        var mkdirsSync = require_mkdirs_sync();
        module22.exports = {
          mkdirs,
          mkdirsSync,
          mkdirp: mkdirs,
          mkdirpSync: mkdirsSync,
          ensureDir: mkdirs,
          ensureDirSync: mkdirsSync
        };
      }
    });
    var require_utimes = __commonJS2({
      "../../node_modules/.pnpm/fs-extra@8.1.0/node_modules/fs-extra/lib/util/utimes.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var fs4 = require_graceful_fs();
        var os = require("os");
        var path4 = require("path");
        function hasMillisResSync() {
          let tmpfile = path4.join("millis-test-sync" + Date.now().toString() + Math.random().toString().slice(2));
          tmpfile = path4.join(os.tmpdir(), tmpfile);
          const d = new Date(1435410243862);
          fs4.writeFileSync(tmpfile, "https://github.com/jprichardson/node-fs-extra/pull/141");
          const fd = fs4.openSync(tmpfile, "r+");
          fs4.futimesSync(fd, d, d);
          fs4.closeSync(fd);
          return fs4.statSync(tmpfile).mtime > 1435410243e3;
        }
        function hasMillisRes(callback) {
          let tmpfile = path4.join("millis-test" + Date.now().toString() + Math.random().toString().slice(2));
          tmpfile = path4.join(os.tmpdir(), tmpfile);
          const d = new Date(1435410243862);
          fs4.writeFile(tmpfile, "https://github.com/jprichardson/node-fs-extra/pull/141", (err) => {
            if (err)
              return callback(err);
            fs4.open(tmpfile, "r+", (err2, fd) => {
              if (err2)
                return callback(err2);
              fs4.futimes(fd, d, d, (err3) => {
                if (err3)
                  return callback(err3);
                fs4.close(fd, (err4) => {
                  if (err4)
                    return callback(err4);
                  fs4.stat(tmpfile, (err5, stats) => {
                    if (err5)
                      return callback(err5);
                    callback(null, stats.mtime > 1435410243e3);
                  });
                });
              });
            });
          });
        }
        function timeRemoveMillis(timestamp) {
          if (typeof timestamp === "number") {
            return Math.floor(timestamp / 1e3) * 1e3;
          } else if (timestamp instanceof Date) {
            return new Date(Math.floor(timestamp.getTime() / 1e3) * 1e3);
          } else {
            throw new Error("fs-extra: timeRemoveMillis() unknown parameter type");
          }
        }
        function utimesMillis(path5, atime, mtime, callback) {
          fs4.open(path5, "r+", (err, fd) => {
            if (err)
              return callback(err);
            fs4.futimes(fd, atime, mtime, (futimesErr) => {
              fs4.close(fd, (closeErr) => {
                if (callback)
                  callback(futimesErr || closeErr);
              });
            });
          });
        }
        function utimesMillisSync(path5, atime, mtime) {
          const fd = fs4.openSync(path5, "r+");
          fs4.futimesSync(fd, atime, mtime);
          return fs4.closeSync(fd);
        }
        module22.exports = {
          hasMillisRes,
          hasMillisResSync,
          timeRemoveMillis,
          utimesMillis,
          utimesMillisSync
        };
      }
    });
    var require_stat = __commonJS2({
      "../../node_modules/.pnpm/fs-extra@8.1.0/node_modules/fs-extra/lib/util/stat.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var fs4 = require_graceful_fs();
        var path4 = require("path");
        var NODE_VERSION_MAJOR_WITH_BIGINT = 10;
        var NODE_VERSION_MINOR_WITH_BIGINT = 5;
        var NODE_VERSION_PATCH_WITH_BIGINT = 0;
        var nodeVersion = process.versions.node.split(".");
        var nodeVersionMajor = Number.parseInt(nodeVersion[0], 10);
        var nodeVersionMinor = Number.parseInt(nodeVersion[1], 10);
        var nodeVersionPatch = Number.parseInt(nodeVersion[2], 10);
        function nodeSupportsBigInt() {
          if (nodeVersionMajor > NODE_VERSION_MAJOR_WITH_BIGINT) {
            return true;
          } else if (nodeVersionMajor === NODE_VERSION_MAJOR_WITH_BIGINT) {
            if (nodeVersionMinor > NODE_VERSION_MINOR_WITH_BIGINT) {
              return true;
            } else if (nodeVersionMinor === NODE_VERSION_MINOR_WITH_BIGINT) {
              if (nodeVersionPatch >= NODE_VERSION_PATCH_WITH_BIGINT) {
                return true;
              }
            }
          }
          return false;
        }
        function getStats(src, dest, cb) {
          if (nodeSupportsBigInt()) {
            fs4.stat(src, { bigint: true }, (err, srcStat) => {
              if (err)
                return cb(err);
              fs4.stat(dest, { bigint: true }, (err2, destStat) => {
                if (err2) {
                  if (err2.code === "ENOENT")
                    return cb(null, { srcStat, destStat: null });
                  return cb(err2);
                }
                return cb(null, { srcStat, destStat });
              });
            });
          } else {
            fs4.stat(src, (err, srcStat) => {
              if (err)
                return cb(err);
              fs4.stat(dest, (err2, destStat) => {
                if (err2) {
                  if (err2.code === "ENOENT")
                    return cb(null, { srcStat, destStat: null });
                  return cb(err2);
                }
                return cb(null, { srcStat, destStat });
              });
            });
          }
        }
        function getStatsSync(src, dest) {
          let srcStat, destStat;
          if (nodeSupportsBigInt()) {
            srcStat = fs4.statSync(src, { bigint: true });
          } else {
            srcStat = fs4.statSync(src);
          }
          try {
            if (nodeSupportsBigInt()) {
              destStat = fs4.statSync(dest, { bigint: true });
            } else {
              destStat = fs4.statSync(dest);
            }
          } catch (err) {
            if (err.code === "ENOENT")
              return { srcStat, destStat: null };
            throw err;
          }
          return { srcStat, destStat };
        }
        function checkPaths(src, dest, funcName, cb) {
          getStats(src, dest, (err, stats) => {
            if (err)
              return cb(err);
            const { srcStat, destStat } = stats;
            if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
              return cb(new Error("Source and destination must not be the same."));
            }
            if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
              return cb(new Error(errMsg(src, dest, funcName)));
            }
            return cb(null, { srcStat, destStat });
          });
        }
        function checkPathsSync(src, dest, funcName) {
          const { srcStat, destStat } = getStatsSync(src, dest);
          if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
            throw new Error("Source and destination must not be the same.");
          }
          if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
            throw new Error(errMsg(src, dest, funcName));
          }
          return { srcStat, destStat };
        }
        function checkParentPaths(src, srcStat, dest, funcName, cb) {
          const srcParent = path4.resolve(path4.dirname(src));
          const destParent = path4.resolve(path4.dirname(dest));
          if (destParent === srcParent || destParent === path4.parse(destParent).root)
            return cb();
          if (nodeSupportsBigInt()) {
            fs4.stat(destParent, { bigint: true }, (err, destStat) => {
              if (err) {
                if (err.code === "ENOENT")
                  return cb();
                return cb(err);
              }
              if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
                return cb(new Error(errMsg(src, dest, funcName)));
              }
              return checkParentPaths(src, srcStat, destParent, funcName, cb);
            });
          } else {
            fs4.stat(destParent, (err, destStat) => {
              if (err) {
                if (err.code === "ENOENT")
                  return cb();
                return cb(err);
              }
              if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
                return cb(new Error(errMsg(src, dest, funcName)));
              }
              return checkParentPaths(src, srcStat, destParent, funcName, cb);
            });
          }
        }
        function checkParentPathsSync(src, srcStat, dest, funcName) {
          const srcParent = path4.resolve(path4.dirname(src));
          const destParent = path4.resolve(path4.dirname(dest));
          if (destParent === srcParent || destParent === path4.parse(destParent).root)
            return;
          let destStat;
          try {
            if (nodeSupportsBigInt()) {
              destStat = fs4.statSync(destParent, { bigint: true });
            } else {
              destStat = fs4.statSync(destParent);
            }
          } catch (err) {
            if (err.code === "ENOENT")
              return;
            throw err;
          }
          if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
            throw new Error(errMsg(src, dest, funcName));
          }
          return checkParentPathsSync(src, srcStat, destParent, funcName);
        }
        function isSrcSubdir(src, dest) {
          const srcArr = path4.resolve(src).split(path4.sep).filter((i) => i);
          const destArr = path4.resolve(dest).split(path4.sep).filter((i) => i);
          return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);
        }
        function errMsg(src, dest, funcName) {
          return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
        }
        module22.exports = {
          checkPaths,
          checkPathsSync,
          checkParentPaths,
          checkParentPathsSync,
          isSrcSubdir
        };
      }
    });
    var require_buffer = __commonJS2({
      "../../node_modules/.pnpm/fs-extra@8.1.0/node_modules/fs-extra/lib/util/buffer.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        module22.exports = function(size) {
          if (typeof Buffer.allocUnsafe === "function") {
            try {
              return Buffer.allocUnsafe(size);
            } catch (e) {
              return new Buffer(size);
            }
          }
          return new Buffer(size);
        };
      }
    });
    var require_copy_sync = __commonJS2({
      "../../node_modules/.pnpm/fs-extra@8.1.0/node_modules/fs-extra/lib/copy-sync/copy-sync.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var fs4 = require_graceful_fs();
        var path4 = require("path");
        var mkdirpSync = require_mkdirs2().mkdirsSync;
        var utimesSync = require_utimes().utimesMillisSync;
        var stat = require_stat();
        function copySync(src, dest, opts) {
          if (typeof opts === "function") {
            opts = { filter: opts };
          }
          opts = opts || {};
          opts.clobber = "clobber" in opts ? !!opts.clobber : true;
          opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
          if (opts.preserveTimestamps && process.arch === "ia32") {
            console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
          }
          const { srcStat, destStat } = stat.checkPathsSync(src, dest, "copy");
          stat.checkParentPathsSync(src, srcStat, dest, "copy");
          return handleFilterAndCopy(destStat, src, dest, opts);
        }
        function handleFilterAndCopy(destStat, src, dest, opts) {
          if (opts.filter && !opts.filter(src, dest))
            return;
          const destParent = path4.dirname(dest);
          if (!fs4.existsSync(destParent))
            mkdirpSync(destParent);
          return startCopy(destStat, src, dest, opts);
        }
        function startCopy(destStat, src, dest, opts) {
          if (opts.filter && !opts.filter(src, dest))
            return;
          return getStats(destStat, src, dest, opts);
        }
        function getStats(destStat, src, dest, opts) {
          const statSync = opts.dereference ? fs4.statSync : fs4.lstatSync;
          const srcStat = statSync(src);
          if (srcStat.isDirectory())
            return onDir(srcStat, destStat, src, dest, opts);
          else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
            return onFile(srcStat, destStat, src, dest, opts);
          else if (srcStat.isSymbolicLink())
            return onLink(destStat, src, dest, opts);
        }
        function onFile(srcStat, destStat, src, dest, opts) {
          if (!destStat)
            return copyFile(srcStat, src, dest, opts);
          return mayCopyFile(srcStat, src, dest, opts);
        }
        function mayCopyFile(srcStat, src, dest, opts) {
          if (opts.overwrite) {
            fs4.unlinkSync(dest);
            return copyFile(srcStat, src, dest, opts);
          } else if (opts.errorOnExist) {
            throw new Error(`'${dest}' already exists`);
          }
        }
        function copyFile(srcStat, src, dest, opts) {
          if (typeof fs4.copyFileSync === "function") {
            fs4.copyFileSync(src, dest);
            fs4.chmodSync(dest, srcStat.mode);
            if (opts.preserveTimestamps) {
              return utimesSync(dest, srcStat.atime, srcStat.mtime);
            }
            return;
          }
          return copyFileFallback(srcStat, src, dest, opts);
        }
        function copyFileFallback(srcStat, src, dest, opts) {
          const BUF_LENGTH = 64 * 1024;
          const _buff = require_buffer()(BUF_LENGTH);
          const fdr = fs4.openSync(src, "r");
          const fdw = fs4.openSync(dest, "w", srcStat.mode);
          let pos = 0;
          while (pos < srcStat.size) {
            const bytesRead = fs4.readSync(fdr, _buff, 0, BUF_LENGTH, pos);
            fs4.writeSync(fdw, _buff, 0, bytesRead);
            pos += bytesRead;
          }
          if (opts.preserveTimestamps)
            fs4.futimesSync(fdw, srcStat.atime, srcStat.mtime);
          fs4.closeSync(fdr);
          fs4.closeSync(fdw);
        }
        function onDir(srcStat, destStat, src, dest, opts) {
          if (!destStat)
            return mkDirAndCopy(srcStat, src, dest, opts);
          if (destStat && !destStat.isDirectory()) {
            throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
          }
          return copyDir(src, dest, opts);
        }
        function mkDirAndCopy(srcStat, src, dest, opts) {
          fs4.mkdirSync(dest);
          copyDir(src, dest, opts);
          return fs4.chmodSync(dest, srcStat.mode);
        }
        function copyDir(src, dest, opts) {
          fs4.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
        }
        function copyDirItem(item, src, dest, opts) {
          const srcItem = path4.join(src, item);
          const destItem = path4.join(dest, item);
          const { destStat } = stat.checkPathsSync(srcItem, destItem, "copy");
          return startCopy(destStat, srcItem, destItem, opts);
        }
        function onLink(destStat, src, dest, opts) {
          let resolvedSrc = fs4.readlinkSync(src);
          if (opts.dereference) {
            resolvedSrc = path4.resolve(process.cwd(), resolvedSrc);
          }
          if (!destStat) {
            return fs4.symlinkSync(resolvedSrc, dest);
          } else {
            let resolvedDest;
            try {
              resolvedDest = fs4.readlinkSync(dest);
            } catch (err) {
              if (err.code === "EINVAL" || err.code === "UNKNOWN")
                return fs4.symlinkSync(resolvedSrc, dest);
              throw err;
            }
            if (opts.dereference) {
              resolvedDest = path4.resolve(process.cwd(), resolvedDest);
            }
            if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
              throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
            }
            if (fs4.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
              throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
            }
            return copyLink(resolvedSrc, dest);
          }
        }
        function copyLink(resolvedSrc, dest) {
          fs4.unlinkSync(dest);
          return fs4.symlinkSync(resolvedSrc, dest);
        }
        module22.exports = copySync;
      }
    });
    var require_copy_sync2 = __commonJS2({
      "../../node_modules/.pnpm/fs-extra@8.1.0/node_modules/fs-extra/lib/copy-sync/index.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        module22.exports = {
          copySync: require_copy_sync()
        };
      }
    });
    var require_path_exists2 = __commonJS2({
      "../../node_modules/.pnpm/fs-extra@8.1.0/node_modules/fs-extra/lib/path-exists/index.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var u = require_universalify().fromPromise;
        var fs4 = require_fs();
        function pathExists(path4) {
          return fs4.access(path4).then(() => true).catch(() => false);
        }
        module22.exports = {
          pathExists: u(pathExists),
          pathExistsSync: fs4.existsSync
        };
      }
    });
    var require_copy = __commonJS2({
      "../../node_modules/.pnpm/fs-extra@8.1.0/node_modules/fs-extra/lib/copy/copy.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var fs4 = require_graceful_fs();
        var path4 = require("path");
        var mkdirp = require_mkdirs2().mkdirs;
        var pathExists = require_path_exists2().pathExists;
        var utimes = require_utimes().utimesMillis;
        var stat = require_stat();
        function copy(src, dest, opts, cb) {
          if (typeof opts === "function" && !cb) {
            cb = opts;
            opts = {};
          } else if (typeof opts === "function") {
            opts = { filter: opts };
          }
          cb = cb || function() {
          };
          opts = opts || {};
          opts.clobber = "clobber" in opts ? !!opts.clobber : true;
          opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
          if (opts.preserveTimestamps && process.arch === "ia32") {
            console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
          }
          stat.checkPaths(src, dest, "copy", (err, stats) => {
            if (err)
              return cb(err);
            const { srcStat, destStat } = stats;
            stat.checkParentPaths(src, srcStat, dest, "copy", (err2) => {
              if (err2)
                return cb(err2);
              if (opts.filter)
                return handleFilter(checkParentDir, destStat, src, dest, opts, cb);
              return checkParentDir(destStat, src, dest, opts, cb);
            });
          });
        }
        function checkParentDir(destStat, src, dest, opts, cb) {
          const destParent = path4.dirname(dest);
          pathExists(destParent, (err, dirExists) => {
            if (err)
              return cb(err);
            if (dirExists)
              return startCopy(destStat, src, dest, opts, cb);
            mkdirp(destParent, (err2) => {
              if (err2)
                return cb(err2);
              return startCopy(destStat, src, dest, opts, cb);
            });
          });
        }
        function handleFilter(onInclude, destStat, src, dest, opts, cb) {
          Promise.resolve(opts.filter(src, dest)).then((include) => {
            if (include)
              return onInclude(destStat, src, dest, opts, cb);
            return cb();
          }, (error) => cb(error));
        }
        function startCopy(destStat, src, dest, opts, cb) {
          if (opts.filter)
            return handleFilter(getStats, destStat, src, dest, opts, cb);
          return getStats(destStat, src, dest, opts, cb);
        }
        function getStats(destStat, src, dest, opts, cb) {
          const stat2 = opts.dereference ? fs4.stat : fs4.lstat;
          stat2(src, (err, srcStat) => {
            if (err)
              return cb(err);
            if (srcStat.isDirectory())
              return onDir(srcStat, destStat, src, dest, opts, cb);
            else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
              return onFile(srcStat, destStat, src, dest, opts, cb);
            else if (srcStat.isSymbolicLink())
              return onLink(destStat, src, dest, opts, cb);
          });
        }
        function onFile(srcStat, destStat, src, dest, opts, cb) {
          if (!destStat)
            return copyFile(srcStat, src, dest, opts, cb);
          return mayCopyFile(srcStat, src, dest, opts, cb);
        }
        function mayCopyFile(srcStat, src, dest, opts, cb) {
          if (opts.overwrite) {
            fs4.unlink(dest, (err) => {
              if (err)
                return cb(err);
              return copyFile(srcStat, src, dest, opts, cb);
            });
          } else if (opts.errorOnExist) {
            return cb(new Error(`'${dest}' already exists`));
          } else
            return cb();
        }
        function copyFile(srcStat, src, dest, opts, cb) {
          if (typeof fs4.copyFile === "function") {
            return fs4.copyFile(src, dest, (err) => {
              if (err)
                return cb(err);
              return setDestModeAndTimestamps(srcStat, dest, opts, cb);
            });
          }
          return copyFileFallback(srcStat, src, dest, opts, cb);
        }
        function copyFileFallback(srcStat, src, dest, opts, cb) {
          const rs = fs4.createReadStream(src);
          rs.on("error", (err) => cb(err)).once("open", () => {
            const ws = fs4.createWriteStream(dest, { mode: srcStat.mode });
            ws.on("error", (err) => cb(err)).on("open", () => rs.pipe(ws)).once("close", () => setDestModeAndTimestamps(srcStat, dest, opts, cb));
          });
        }
        function setDestModeAndTimestamps(srcStat, dest, opts, cb) {
          fs4.chmod(dest, srcStat.mode, (err) => {
            if (err)
              return cb(err);
            if (opts.preserveTimestamps) {
              return utimes(dest, srcStat.atime, srcStat.mtime, cb);
            }
            return cb();
          });
        }
        function onDir(srcStat, destStat, src, dest, opts, cb) {
          if (!destStat)
            return mkDirAndCopy(srcStat, src, dest, opts, cb);
          if (destStat && !destStat.isDirectory()) {
            return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
          }
          return copyDir(src, dest, opts, cb);
        }
        function mkDirAndCopy(srcStat, src, dest, opts, cb) {
          fs4.mkdir(dest, (err) => {
            if (err)
              return cb(err);
            copyDir(src, dest, opts, (err2) => {
              if (err2)
                return cb(err2);
              return fs4.chmod(dest, srcStat.mode, cb);
            });
          });
        }
        function copyDir(src, dest, opts, cb) {
          fs4.readdir(src, (err, items) => {
            if (err)
              return cb(err);
            return copyDirItems(items, src, dest, opts, cb);
          });
        }
        function copyDirItems(items, src, dest, opts, cb) {
          const item = items.pop();
          if (!item)
            return cb();
          return copyDirItem(items, item, src, dest, opts, cb);
        }
        function copyDirItem(items, item, src, dest, opts, cb) {
          const srcItem = path4.join(src, item);
          const destItem = path4.join(dest, item);
          stat.checkPaths(srcItem, destItem, "copy", (err, stats) => {
            if (err)
              return cb(err);
            const { destStat } = stats;
            startCopy(destStat, srcItem, destItem, opts, (err2) => {
              if (err2)
                return cb(err2);
              return copyDirItems(items, src, dest, opts, cb);
            });
          });
        }
        function onLink(destStat, src, dest, opts, cb) {
          fs4.readlink(src, (err, resolvedSrc) => {
            if (err)
              return cb(err);
            if (opts.dereference) {
              resolvedSrc = path4.resolve(process.cwd(), resolvedSrc);
            }
            if (!destStat) {
              return fs4.symlink(resolvedSrc, dest, cb);
            } else {
              fs4.readlink(dest, (err2, resolvedDest) => {
                if (err2) {
                  if (err2.code === "EINVAL" || err2.code === "UNKNOWN")
                    return fs4.symlink(resolvedSrc, dest, cb);
                  return cb(err2);
                }
                if (opts.dereference) {
                  resolvedDest = path4.resolve(process.cwd(), resolvedDest);
                }
                if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
                  return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
                }
                if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
                  return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
                }
                return copyLink(resolvedSrc, dest, cb);
              });
            }
          });
        }
        function copyLink(resolvedSrc, dest, cb) {
          fs4.unlink(dest, (err) => {
            if (err)
              return cb(err);
            return fs4.symlink(resolvedSrc, dest, cb);
          });
        }
        module22.exports = copy;
      }
    });
    var require_copy2 = __commonJS2({
      "../../node_modules/.pnpm/fs-extra@8.1.0/node_modules/fs-extra/lib/copy/index.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var u = require_universalify().fromCallback;
        module22.exports = {
          copy: u(require_copy())
        };
      }
    });
    var require_rimraf = __commonJS2({
      "../../node_modules/.pnpm/fs-extra@8.1.0/node_modules/fs-extra/lib/remove/rimraf.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var fs4 = require_graceful_fs();
        var path4 = require("path");
        var assert = require("assert");
        var isWindows = process.platform === "win32";
        function defaults(options) {
          const methods = [
            "unlink",
            "chmod",
            "stat",
            "lstat",
            "rmdir",
            "readdir"
          ];
          methods.forEach((m) => {
            options[m] = options[m] || fs4[m];
            m = m + "Sync";
            options[m] = options[m] || fs4[m];
          });
          options.maxBusyTries = options.maxBusyTries || 3;
        }
        function rimraf(p, options, cb) {
          let busyTries = 0;
          if (typeof options === "function") {
            cb = options;
            options = {};
          }
          assert(p, "rimraf: missing path");
          assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
          assert.strictEqual(typeof cb, "function", "rimraf: callback function required");
          assert(options, "rimraf: invalid options argument provided");
          assert.strictEqual(typeof options, "object", "rimraf: options should be object");
          defaults(options);
          rimraf_(p, options, function CB(er) {
            if (er) {
              if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
                busyTries++;
                const time = busyTries * 100;
                return setTimeout(() => rimraf_(p, options, CB), time);
              }
              if (er.code === "ENOENT")
                er = null;
            }
            cb(er);
          });
        }
        function rimraf_(p, options, cb) {
          assert(p);
          assert(options);
          assert(typeof cb === "function");
          options.lstat(p, (er, st) => {
            if (er && er.code === "ENOENT") {
              return cb(null);
            }
            if (er && er.code === "EPERM" && isWindows) {
              return fixWinEPERM(p, options, er, cb);
            }
            if (st && st.isDirectory()) {
              return rmdir(p, options, er, cb);
            }
            options.unlink(p, (er2) => {
              if (er2) {
                if (er2.code === "ENOENT") {
                  return cb(null);
                }
                if (er2.code === "EPERM") {
                  return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
                }
                if (er2.code === "EISDIR") {
                  return rmdir(p, options, er2, cb);
                }
              }
              return cb(er2);
            });
          });
        }
        function fixWinEPERM(p, options, er, cb) {
          assert(p);
          assert(options);
          assert(typeof cb === "function");
          if (er) {
            assert(er instanceof Error);
          }
          options.chmod(p, 438, (er2) => {
            if (er2) {
              cb(er2.code === "ENOENT" ? null : er);
            } else {
              options.stat(p, (er3, stats) => {
                if (er3) {
                  cb(er3.code === "ENOENT" ? null : er);
                } else if (stats.isDirectory()) {
                  rmdir(p, options, er, cb);
                } else {
                  options.unlink(p, cb);
                }
              });
            }
          });
        }
        function fixWinEPERMSync(p, options, er) {
          let stats;
          assert(p);
          assert(options);
          if (er) {
            assert(er instanceof Error);
          }
          try {
            options.chmodSync(p, 438);
          } catch (er2) {
            if (er2.code === "ENOENT") {
              return;
            } else {
              throw er;
            }
          }
          try {
            stats = options.statSync(p);
          } catch (er3) {
            if (er3.code === "ENOENT") {
              return;
            } else {
              throw er;
            }
          }
          if (stats.isDirectory()) {
            rmdirSync(p, options, er);
          } else {
            options.unlinkSync(p);
          }
        }
        function rmdir(p, options, originalEr, cb) {
          assert(p);
          assert(options);
          if (originalEr) {
            assert(originalEr instanceof Error);
          }
          assert(typeof cb === "function");
          options.rmdir(p, (er) => {
            if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) {
              rmkids(p, options, cb);
            } else if (er && er.code === "ENOTDIR") {
              cb(originalEr);
            } else {
              cb(er);
            }
          });
        }
        function rmkids(p, options, cb) {
          assert(p);
          assert(options);
          assert(typeof cb === "function");
          options.readdir(p, (er, files) => {
            if (er)
              return cb(er);
            let n = files.length;
            let errState;
            if (n === 0)
              return options.rmdir(p, cb);
            files.forEach((f) => {
              rimraf(path4.join(p, f), options, (er2) => {
                if (errState) {
                  return;
                }
                if (er2)
                  return cb(errState = er2);
                if (--n === 0) {
                  options.rmdir(p, cb);
                }
              });
            });
          });
        }
        function rimrafSync(p, options) {
          let st;
          options = options || {};
          defaults(options);
          assert(p, "rimraf: missing path");
          assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
          assert(options, "rimraf: missing options");
          assert.strictEqual(typeof options, "object", "rimraf: options should be object");
          try {
            st = options.lstatSync(p);
          } catch (er) {
            if (er.code === "ENOENT") {
              return;
            }
            if (er.code === "EPERM" && isWindows) {
              fixWinEPERMSync(p, options, er);
            }
          }
          try {
            if (st && st.isDirectory()) {
              rmdirSync(p, options, null);
            } else {
              options.unlinkSync(p);
            }
          } catch (er) {
            if (er.code === "ENOENT") {
              return;
            } else if (er.code === "EPERM") {
              return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
            } else if (er.code !== "EISDIR") {
              throw er;
            }
            rmdirSync(p, options, er);
          }
        }
        function rmdirSync(p, options, originalEr) {
          assert(p);
          assert(options);
          if (originalEr) {
            assert(originalEr instanceof Error);
          }
          try {
            options.rmdirSync(p);
          } catch (er) {
            if (er.code === "ENOTDIR") {
              throw originalEr;
            } else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") {
              rmkidsSync(p, options);
            } else if (er.code !== "ENOENT") {
              throw er;
            }
          }
        }
        function rmkidsSync(p, options) {
          assert(p);
          assert(options);
          options.readdirSync(p).forEach((f) => rimrafSync(path4.join(p, f), options));
          if (isWindows) {
            const startTime = Date.now();
            do {
              try {
                const ret = options.rmdirSync(p, options);
                return ret;
              } catch (er) {
              }
            } while (Date.now() - startTime < 500);
          } else {
            const ret = options.rmdirSync(p, options);
            return ret;
          }
        }
        module22.exports = rimraf;
        rimraf.sync = rimrafSync;
      }
    });
    var require_remove = __commonJS2({
      "../../node_modules/.pnpm/fs-extra@8.1.0/node_modules/fs-extra/lib/remove/index.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var u = require_universalify().fromCallback;
        var rimraf = require_rimraf();
        module22.exports = {
          remove: u(rimraf),
          removeSync: rimraf.sync
        };
      }
    });
    var require_empty = __commonJS2({
      "../../node_modules/.pnpm/fs-extra@8.1.0/node_modules/fs-extra/lib/empty/index.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var u = require_universalify().fromCallback;
        var fs4 = require_graceful_fs();
        var path4 = require("path");
        var mkdir = require_mkdirs2();
        var remove = require_remove();
        var emptyDir = u(function emptyDir2(dir, callback) {
          callback = callback || function() {
          };
          fs4.readdir(dir, (err, items) => {
            if (err)
              return mkdir.mkdirs(dir, callback);
            items = items.map((item) => path4.join(dir, item));
            deleteItem();
            function deleteItem() {
              const item = items.pop();
              if (!item)
                return callback();
              remove.remove(item, (err2) => {
                if (err2)
                  return callback(err2);
                deleteItem();
              });
            }
          });
        });
        function emptyDirSync(dir) {
          let items;
          try {
            items = fs4.readdirSync(dir);
          } catch (err) {
            return mkdir.mkdirsSync(dir);
          }
          items.forEach((item) => {
            item = path4.join(dir, item);
            remove.removeSync(item);
          });
        }
        module22.exports = {
          emptyDirSync,
          emptydirSync: emptyDirSync,
          emptyDir,
          emptydir: emptyDir
        };
      }
    });
    var require_file = __commonJS2({
      "../../node_modules/.pnpm/fs-extra@8.1.0/node_modules/fs-extra/lib/ensure/file.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var u = require_universalify().fromCallback;
        var path4 = require("path");
        var fs4 = require_graceful_fs();
        var mkdir = require_mkdirs2();
        var pathExists = require_path_exists2().pathExists;
        function createFile(file, callback) {
          function makeFile() {
            fs4.writeFile(file, "", (err) => {
              if (err)
                return callback(err);
              callback();
            });
          }
          fs4.stat(file, (err, stats) => {
            if (!err && stats.isFile())
              return callback();
            const dir = path4.dirname(file);
            pathExists(dir, (err2, dirExists) => {
              if (err2)
                return callback(err2);
              if (dirExists)
                return makeFile();
              mkdir.mkdirs(dir, (err3) => {
                if (err3)
                  return callback(err3);
                makeFile();
              });
            });
          });
        }
        function createFileSync(file) {
          let stats;
          try {
            stats = fs4.statSync(file);
          } catch (e) {
          }
          if (stats && stats.isFile())
            return;
          const dir = path4.dirname(file);
          if (!fs4.existsSync(dir)) {
            mkdir.mkdirsSync(dir);
          }
          fs4.writeFileSync(file, "");
        }
        module22.exports = {
          createFile: u(createFile),
          createFileSync
        };
      }
    });
    var require_link = __commonJS2({
      "../../node_modules/.pnpm/fs-extra@8.1.0/node_modules/fs-extra/lib/ensure/link.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var u = require_universalify().fromCallback;
        var path4 = require("path");
        var fs4 = require_graceful_fs();
        var mkdir = require_mkdirs2();
        var pathExists = require_path_exists2().pathExists;
        function createLink(srcpath, dstpath, callback) {
          function makeLink(srcpath2, dstpath2) {
            fs4.link(srcpath2, dstpath2, (err) => {
              if (err)
                return callback(err);
              callback(null);
            });
          }
          pathExists(dstpath, (err, destinationExists) => {
            if (err)
              return callback(err);
            if (destinationExists)
              return callback(null);
            fs4.lstat(srcpath, (err2) => {
              if (err2) {
                err2.message = err2.message.replace("lstat", "ensureLink");
                return callback(err2);
              }
              const dir = path4.dirname(dstpath);
              pathExists(dir, (err3, dirExists) => {
                if (err3)
                  return callback(err3);
                if (dirExists)
                  return makeLink(srcpath, dstpath);
                mkdir.mkdirs(dir, (err4) => {
                  if (err4)
                    return callback(err4);
                  makeLink(srcpath, dstpath);
                });
              });
            });
          });
        }
        function createLinkSync(srcpath, dstpath) {
          const destinationExists = fs4.existsSync(dstpath);
          if (destinationExists)
            return void 0;
          try {
            fs4.lstatSync(srcpath);
          } catch (err) {
            err.message = err.message.replace("lstat", "ensureLink");
            throw err;
          }
          const dir = path4.dirname(dstpath);
          const dirExists = fs4.existsSync(dir);
          if (dirExists)
            return fs4.linkSync(srcpath, dstpath);
          mkdir.mkdirsSync(dir);
          return fs4.linkSync(srcpath, dstpath);
        }
        module22.exports = {
          createLink: u(createLink),
          createLinkSync
        };
      }
    });
    var require_symlink_paths = __commonJS2({
      "../../node_modules/.pnpm/fs-extra@8.1.0/node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var path4 = require("path");
        var fs4 = require_graceful_fs();
        var pathExists = require_path_exists2().pathExists;
        function symlinkPaths(srcpath, dstpath, callback) {
          if (path4.isAbsolute(srcpath)) {
            return fs4.lstat(srcpath, (err) => {
              if (err) {
                err.message = err.message.replace("lstat", "ensureSymlink");
                return callback(err);
              }
              return callback(null, {
                "toCwd": srcpath,
                "toDst": srcpath
              });
            });
          } else {
            const dstdir = path4.dirname(dstpath);
            const relativeToDst = path4.join(dstdir, srcpath);
            return pathExists(relativeToDst, (err, exists) => {
              if (err)
                return callback(err);
              if (exists) {
                return callback(null, {
                  "toCwd": relativeToDst,
                  "toDst": srcpath
                });
              } else {
                return fs4.lstat(srcpath, (err2) => {
                  if (err2) {
                    err2.message = err2.message.replace("lstat", "ensureSymlink");
                    return callback(err2);
                  }
                  return callback(null, {
                    "toCwd": srcpath,
                    "toDst": path4.relative(dstdir, srcpath)
                  });
                });
              }
            });
          }
        }
        function symlinkPathsSync(srcpath, dstpath) {
          let exists;
          if (path4.isAbsolute(srcpath)) {
            exists = fs4.existsSync(srcpath);
            if (!exists)
              throw new Error("absolute srcpath does not exist");
            return {
              "toCwd": srcpath,
              "toDst": srcpath
            };
          } else {
            const dstdir = path4.dirname(dstpath);
            const relativeToDst = path4.join(dstdir, srcpath);
            exists = fs4.existsSync(relativeToDst);
            if (exists) {
              return {
                "toCwd": relativeToDst,
                "toDst": srcpath
              };
            } else {
              exists = fs4.existsSync(srcpath);
              if (!exists)
                throw new Error("relative srcpath does not exist");
              return {
                "toCwd": srcpath,
                "toDst": path4.relative(dstdir, srcpath)
              };
            }
          }
        }
        module22.exports = {
          symlinkPaths,
          symlinkPathsSync
        };
      }
    });
    var require_symlink_type = __commonJS2({
      "../../node_modules/.pnpm/fs-extra@8.1.0/node_modules/fs-extra/lib/ensure/symlink-type.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var fs4 = require_graceful_fs();
        function symlinkType(srcpath, type, callback) {
          callback = typeof type === "function" ? type : callback;
          type = typeof type === "function" ? false : type;
          if (type)
            return callback(null, type);
          fs4.lstat(srcpath, (err, stats) => {
            if (err)
              return callback(null, "file");
            type = stats && stats.isDirectory() ? "dir" : "file";
            callback(null, type);
          });
        }
        function symlinkTypeSync(srcpath, type) {
          let stats;
          if (type)
            return type;
          try {
            stats = fs4.lstatSync(srcpath);
          } catch (e) {
            return "file";
          }
          return stats && stats.isDirectory() ? "dir" : "file";
        }
        module22.exports = {
          symlinkType,
          symlinkTypeSync
        };
      }
    });
    var require_symlink = __commonJS2({
      "../../node_modules/.pnpm/fs-extra@8.1.0/node_modules/fs-extra/lib/ensure/symlink.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var u = require_universalify().fromCallback;
        var path4 = require("path");
        var fs4 = require_graceful_fs();
        var _mkdirs = require_mkdirs2();
        var mkdirs = _mkdirs.mkdirs;
        var mkdirsSync = _mkdirs.mkdirsSync;
        var _symlinkPaths = require_symlink_paths();
        var symlinkPaths = _symlinkPaths.symlinkPaths;
        var symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
        var _symlinkType = require_symlink_type();
        var symlinkType = _symlinkType.symlinkType;
        var symlinkTypeSync = _symlinkType.symlinkTypeSync;
        var pathExists = require_path_exists2().pathExists;
        function createSymlink(srcpath, dstpath, type, callback) {
          callback = typeof type === "function" ? type : callback;
          type = typeof type === "function" ? false : type;
          pathExists(dstpath, (err, destinationExists) => {
            if (err)
              return callback(err);
            if (destinationExists)
              return callback(null);
            symlinkPaths(srcpath, dstpath, (err2, relative) => {
              if (err2)
                return callback(err2);
              srcpath = relative.toDst;
              symlinkType(relative.toCwd, type, (err3, type2) => {
                if (err3)
                  return callback(err3);
                const dir = path4.dirname(dstpath);
                pathExists(dir, (err4, dirExists) => {
                  if (err4)
                    return callback(err4);
                  if (dirExists)
                    return fs4.symlink(srcpath, dstpath, type2, callback);
                  mkdirs(dir, (err5) => {
                    if (err5)
                      return callback(err5);
                    fs4.symlink(srcpath, dstpath, type2, callback);
                  });
                });
              });
            });
          });
        }
        function createSymlinkSync(srcpath, dstpath, type) {
          const destinationExists = fs4.existsSync(dstpath);
          if (destinationExists)
            return void 0;
          const relative = symlinkPathsSync(srcpath, dstpath);
          srcpath = relative.toDst;
          type = symlinkTypeSync(relative.toCwd, type);
          const dir = path4.dirname(dstpath);
          const exists = fs4.existsSync(dir);
          if (exists)
            return fs4.symlinkSync(srcpath, dstpath, type);
          mkdirsSync(dir);
          return fs4.symlinkSync(srcpath, dstpath, type);
        }
        module22.exports = {
          createSymlink: u(createSymlink),
          createSymlinkSync
        };
      }
    });
    var require_ensure = __commonJS2({
      "../../node_modules/.pnpm/fs-extra@8.1.0/node_modules/fs-extra/lib/ensure/index.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var file = require_file();
        var link = require_link();
        var symlink = require_symlink();
        module22.exports = {
          createFile: file.createFile,
          createFileSync: file.createFileSync,
          ensureFile: file.createFile,
          ensureFileSync: file.createFileSync,
          createLink: link.createLink,
          createLinkSync: link.createLinkSync,
          ensureLink: link.createLink,
          ensureLinkSync: link.createLinkSync,
          createSymlink: symlink.createSymlink,
          createSymlinkSync: symlink.createSymlinkSync,
          ensureSymlink: symlink.createSymlink,
          ensureSymlinkSync: symlink.createSymlinkSync
        };
      }
    });
    var require_jsonfile = __commonJS2({
      "../../node_modules/.pnpm/jsonfile@4.0.0/node_modules/jsonfile/index.js"(exports2, module22) {
        init_cjs_shims();
        var _fs;
        try {
          _fs = require_graceful_fs();
        } catch (_) {
          _fs = require("fs");
        }
        function readFile(file, options, callback) {
          if (callback == null) {
            callback = options;
            options = {};
          }
          if (typeof options === "string") {
            options = { encoding: options };
          }
          options = options || {};
          var fs4 = options.fs || _fs;
          var shouldThrow = true;
          if ("throws" in options) {
            shouldThrow = options.throws;
          }
          fs4.readFile(file, options, function(err, data) {
            if (err)
              return callback(err);
            data = stripBom(data);
            var obj;
            try {
              obj = JSON.parse(data, options ? options.reviver : null);
            } catch (err2) {
              if (shouldThrow) {
                err2.message = file + ": " + err2.message;
                return callback(err2);
              } else {
                return callback(null, null);
              }
            }
            callback(null, obj);
          });
        }
        function readFileSync(file, options) {
          options = options || {};
          if (typeof options === "string") {
            options = { encoding: options };
          }
          var fs4 = options.fs || _fs;
          var shouldThrow = true;
          if ("throws" in options) {
            shouldThrow = options.throws;
          }
          try {
            var content = fs4.readFileSync(file, options);
            content = stripBom(content);
            return JSON.parse(content, options.reviver);
          } catch (err) {
            if (shouldThrow) {
              err.message = file + ": " + err.message;
              throw err;
            } else {
              return null;
            }
          }
        }
        function stringify(obj, options) {
          var spaces;
          var EOL = "\n";
          if (typeof options === "object" && options !== null) {
            if (options.spaces) {
              spaces = options.spaces;
            }
            if (options.EOL) {
              EOL = options.EOL;
            }
          }
          var str = JSON.stringify(obj, options ? options.replacer : null, spaces);
          return str.replace(/\n/g, EOL) + EOL;
        }
        function writeFile(file, obj, options, callback) {
          if (callback == null) {
            callback = options;
            options = {};
          }
          options = options || {};
          var fs4 = options.fs || _fs;
          var str = "";
          try {
            str = stringify(obj, options);
          } catch (err) {
            if (callback)
              callback(err, null);
            return;
          }
          fs4.writeFile(file, str, options, callback);
        }
        function writeFileSync(file, obj, options) {
          options = options || {};
          var fs4 = options.fs || _fs;
          var str = stringify(obj, options);
          return fs4.writeFileSync(file, str, options);
        }
        function stripBom(content) {
          if (Buffer.isBuffer(content))
            content = content.toString("utf8");
          content = content.replace(/^\uFEFF/, "");
          return content;
        }
        var jsonfile = {
          readFile,
          readFileSync,
          writeFile,
          writeFileSync
        };
        module22.exports = jsonfile;
      }
    });
    var require_jsonfile2 = __commonJS2({
      "../../node_modules/.pnpm/fs-extra@8.1.0/node_modules/fs-extra/lib/json/jsonfile.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var u = require_universalify().fromCallback;
        var jsonFile = require_jsonfile();
        module22.exports = {
          readJson: u(jsonFile.readFile),
          readJsonSync: jsonFile.readFileSync,
          writeJson: u(jsonFile.writeFile),
          writeJsonSync: jsonFile.writeFileSync
        };
      }
    });
    var require_output_json = __commonJS2({
      "../../node_modules/.pnpm/fs-extra@8.1.0/node_modules/fs-extra/lib/json/output-json.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var path4 = require("path");
        var mkdir = require_mkdirs2();
        var pathExists = require_path_exists2().pathExists;
        var jsonFile = require_jsonfile2();
        function outputJson(file, data, options, callback) {
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          const dir = path4.dirname(file);
          pathExists(dir, (err, itDoes) => {
            if (err)
              return callback(err);
            if (itDoes)
              return jsonFile.writeJson(file, data, options, callback);
            mkdir.mkdirs(dir, (err2) => {
              if (err2)
                return callback(err2);
              jsonFile.writeJson(file, data, options, callback);
            });
          });
        }
        module22.exports = outputJson;
      }
    });
    var require_output_json_sync = __commonJS2({
      "../../node_modules/.pnpm/fs-extra@8.1.0/node_modules/fs-extra/lib/json/output-json-sync.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var fs4 = require_graceful_fs();
        var path4 = require("path");
        var mkdir = require_mkdirs2();
        var jsonFile = require_jsonfile2();
        function outputJsonSync(file, data, options) {
          const dir = path4.dirname(file);
          if (!fs4.existsSync(dir)) {
            mkdir.mkdirsSync(dir);
          }
          jsonFile.writeJsonSync(file, data, options);
        }
        module22.exports = outputJsonSync;
      }
    });
    var require_json = __commonJS2({
      "../../node_modules/.pnpm/fs-extra@8.1.0/node_modules/fs-extra/lib/json/index.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var u = require_universalify().fromCallback;
        var jsonFile = require_jsonfile2();
        jsonFile.outputJson = u(require_output_json());
        jsonFile.outputJsonSync = require_output_json_sync();
        jsonFile.outputJSON = jsonFile.outputJson;
        jsonFile.outputJSONSync = jsonFile.outputJsonSync;
        jsonFile.writeJSON = jsonFile.writeJson;
        jsonFile.writeJSONSync = jsonFile.writeJsonSync;
        jsonFile.readJSON = jsonFile.readJson;
        jsonFile.readJSONSync = jsonFile.readJsonSync;
        module22.exports = jsonFile;
      }
    });
    var require_move_sync = __commonJS2({
      "../../node_modules/.pnpm/fs-extra@8.1.0/node_modules/fs-extra/lib/move-sync/move-sync.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var fs4 = require_graceful_fs();
        var path4 = require("path");
        var copySync = require_copy_sync2().copySync;
        var removeSync = require_remove().removeSync;
        var mkdirpSync = require_mkdirs2().mkdirpSync;
        var stat = require_stat();
        function moveSync(src, dest, opts) {
          opts = opts || {};
          const overwrite = opts.overwrite || opts.clobber || false;
          const { srcStat } = stat.checkPathsSync(src, dest, "move");
          stat.checkParentPathsSync(src, srcStat, dest, "move");
          mkdirpSync(path4.dirname(dest));
          return doRename(src, dest, overwrite);
        }
        function doRename(src, dest, overwrite) {
          if (overwrite) {
            removeSync(dest);
            return rename(src, dest, overwrite);
          }
          if (fs4.existsSync(dest))
            throw new Error("dest already exists.");
          return rename(src, dest, overwrite);
        }
        function rename(src, dest, overwrite) {
          try {
            fs4.renameSync(src, dest);
          } catch (err) {
            if (err.code !== "EXDEV")
              throw err;
            return moveAcrossDevice(src, dest, overwrite);
          }
        }
        function moveAcrossDevice(src, dest, overwrite) {
          const opts = {
            overwrite,
            errorOnExist: true
          };
          copySync(src, dest, opts);
          return removeSync(src);
        }
        module22.exports = moveSync;
      }
    });
    var require_move_sync2 = __commonJS2({
      "../../node_modules/.pnpm/fs-extra@8.1.0/node_modules/fs-extra/lib/move-sync/index.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        module22.exports = {
          moveSync: require_move_sync()
        };
      }
    });
    var require_move = __commonJS2({
      "../../node_modules/.pnpm/fs-extra@8.1.0/node_modules/fs-extra/lib/move/move.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var fs4 = require_graceful_fs();
        var path4 = require("path");
        var copy = require_copy2().copy;
        var remove = require_remove().remove;
        var mkdirp = require_mkdirs2().mkdirp;
        var pathExists = require_path_exists2().pathExists;
        var stat = require_stat();
        function move(src, dest, opts, cb) {
          if (typeof opts === "function") {
            cb = opts;
            opts = {};
          }
          const overwrite = opts.overwrite || opts.clobber || false;
          stat.checkPaths(src, dest, "move", (err, stats) => {
            if (err)
              return cb(err);
            const { srcStat } = stats;
            stat.checkParentPaths(src, srcStat, dest, "move", (err2) => {
              if (err2)
                return cb(err2);
              mkdirp(path4.dirname(dest), (err3) => {
                if (err3)
                  return cb(err3);
                return doRename(src, dest, overwrite, cb);
              });
            });
          });
        }
        function doRename(src, dest, overwrite, cb) {
          if (overwrite) {
            return remove(dest, (err) => {
              if (err)
                return cb(err);
              return rename(src, dest, overwrite, cb);
            });
          }
          pathExists(dest, (err, destExists) => {
            if (err)
              return cb(err);
            if (destExists)
              return cb(new Error("dest already exists."));
            return rename(src, dest, overwrite, cb);
          });
        }
        function rename(src, dest, overwrite, cb) {
          fs4.rename(src, dest, (err) => {
            if (!err)
              return cb();
            if (err.code !== "EXDEV")
              return cb(err);
            return moveAcrossDevice(src, dest, overwrite, cb);
          });
        }
        function moveAcrossDevice(src, dest, overwrite, cb) {
          const opts = {
            overwrite,
            errorOnExist: true
          };
          copy(src, dest, opts, (err) => {
            if (err)
              return cb(err);
            return remove(src, cb);
          });
        }
        module22.exports = move;
      }
    });
    var require_move2 = __commonJS2({
      "../../node_modules/.pnpm/fs-extra@8.1.0/node_modules/fs-extra/lib/move/index.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var u = require_universalify().fromCallback;
        module22.exports = {
          move: u(require_move())
        };
      }
    });
    var require_output = __commonJS2({
      "../../node_modules/.pnpm/fs-extra@8.1.0/node_modules/fs-extra/lib/output/index.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        var u = require_universalify().fromCallback;
        var fs4 = require_graceful_fs();
        var path4 = require("path");
        var mkdir = require_mkdirs2();
        var pathExists = require_path_exists2().pathExists;
        function outputFile(file, data, encoding, callback) {
          if (typeof encoding === "function") {
            callback = encoding;
            encoding = "utf8";
          }
          const dir = path4.dirname(file);
          pathExists(dir, (err, itDoes) => {
            if (err)
              return callback(err);
            if (itDoes)
              return fs4.writeFile(file, data, encoding, callback);
            mkdir.mkdirs(dir, (err2) => {
              if (err2)
                return callback(err2);
              fs4.writeFile(file, data, encoding, callback);
            });
          });
        }
        function outputFileSync(file, ...args) {
          const dir = path4.dirname(file);
          if (fs4.existsSync(dir)) {
            return fs4.writeFileSync(file, ...args);
          }
          mkdir.mkdirsSync(dir);
          fs4.writeFileSync(file, ...args);
        }
        module22.exports = {
          outputFile: u(outputFile),
          outputFileSync
        };
      }
    });
    var require_lib = __commonJS2({
      "../../node_modules/.pnpm/fs-extra@8.1.0/node_modules/fs-extra/lib/index.js"(exports2, module22) {
        "use strict";
        init_cjs_shims();
        module22.exports = Object.assign(
          {},
          require_fs(),
          require_copy_sync2(),
          require_copy2(),
          require_empty(),
          require_ensure(),
          require_json(),
          require_mkdirs2(),
          require_move_sync2(),
          require_move2(),
          require_output(),
          require_path_exists2(),
          require_remove()
        );
        var fs4 = require("fs");
        if (Object.getOwnPropertyDescriptor(fs4, "promises")) {
          Object.defineProperty(module22.exports, "promises", {
            get() {
              return fs4.promises;
            }
          });
        }
      }
    });
    var src_exports = {};
    __export2(src_exports, {
      getScopeFromArgs: () => getScopeFromArgs_default,
      getScopeFromPath: () => getScopeFromPath_default,
      getTurboRoot: () => getTurboRoot_default,
      searchUp: () => searchUp_default
    });
    module2.exports = __toCommonJS2(src_exports);
    init_cjs_shims();
    init_cjs_shims();
    function getScopeFromArgs({ args }) {
      if (args.length && args[0] != null) {
        return { scope: args[0], context: {} };
      }
      return { scope: null, context: {} };
    }
    var getScopeFromArgs_default = getScopeFromArgs;
    init_cjs_shims();
    var import_fs2 = __toESM2(require("fs"));
    var import_path = __toESM2(require("path"));
    function getScopeFromPath({ cwd }) {
      const packageJsonPath = import_path.default.join(cwd, "package.json");
      try {
        const raw = import_fs2.default.readFileSync(packageJsonPath, "utf8");
        const packageJsonContent = JSON.parse(raw);
        return {
          scope: packageJsonContent.name,
          context: { path: packageJsonPath }
        };
      } catch (e) {
        return { scope: null, context: {} };
      }
    }
    var getScopeFromPath_default = getScopeFromPath;
    init_cjs_shims();
    init_cjs_shims();
    var import_regenerator = __toESM2(require_regenerator());
    init_cjs_shims();
    init_cjs_shims();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    init_cjs_shims();
    init_cjs_shims();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    init_cjs_shims();
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self);
    }
    init_cjs_shims();
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    init_cjs_shims();
    init_cjs_shims();
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperty(subClass, "prototype", {
        writable: false
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    init_cjs_shims();
    init_cjs_shims();
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    init_cjs_shims();
    init_cjs_shims();
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct.bind();
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    var import_find_up = __toESM2(require_find_up());
    var import_path2 = __toESM2(require("path"));
    var import_fs_extra = __toESM2(require_lib());
    var NoPkgJsonFound = /* @__PURE__ */ function(_Error) {
      _inherits(NoPkgJsonFound2, _Error);
      function NoPkgJsonFound2(directory) {
        var _this;
        _classCallCheck(this, NoPkgJsonFound2);
        _this = _possibleConstructorReturn(this, _getPrototypeOf(NoPkgJsonFound2).call(this, "No package.json could be found upwards from the directory ".concat(directory)));
        _this.directory = directory;
        return _this;
      }
      return NoPkgJsonFound2;
    }(_wrapNativeSuper(Error));
    function hasWorkspacesConfiguredViaPkgJsonSync(directory, firstPkgJsonDirRef) {
      try {
        var pkgJson = import_fs_extra.default.readJsonSync(import_path2.default.join(directory, "package.json"));
        if (firstPkgJsonDirRef.current === void 0) {
          firstPkgJsonDirRef.current = directory;
        }
        if (pkgJson.workspaces || pkgJson.bolt) {
          return directory;
        }
      } catch (err) {
        if (err.code !== "ENOENT") {
          throw err;
        }
      }
    }
    function hasWorkspacesConfiguredViaLernaSync(directory) {
      try {
        var lernaJson = import_fs_extra.default.readJsonSync(import_path2.default.join(directory, "lerna.json"));
        if (lernaJson.useWorkspaces !== true) {
          return directory;
        }
      } catch (err) {
        if (err.code !== "ENOENT") {
          throw err;
        }
      }
    }
    function hasWorkspacesConfiguredViaPnpmSync(directory) {
      var pnpmWorkspacesFileExists = import_fs_extra.default.existsSync(import_path2.default.join(directory, "pnpm-workspace.yaml"));
      if (pnpmWorkspacesFileExists) {
        return directory;
      }
    }
    function findRootSync(cwd) {
      var firstPkgJsonDirRef = {
        current: void 0
      };
      var dir = (0, import_find_up.sync)(function(directory) {
        return [hasWorkspacesConfiguredViaLernaSync(directory), hasWorkspacesConfiguredViaPkgJsonSync(directory, firstPkgJsonDirRef), hasWorkspacesConfiguredViaPnpmSync(directory)].find(function(dir2) {
          return dir2;
        });
      }, {
        cwd,
        type: "directory"
      });
      if (firstPkgJsonDirRef.current === void 0) {
        throw new NoPkgJsonFound(cwd);
      }
      if (dir === void 0) {
        return firstPkgJsonDirRef.current;
      }
      return dir;
    }
    init_cjs_shims();
    var import_fs22 = __toESM2(require("fs"));
    var import_path3 = __toESM2(require("path"));
    function searchUp({
      target,
      cwd
    }) {
      const root = import_path3.default.parse(cwd).root;
      let found = false;
      while (!found && cwd !== root) {
        if (import_fs22.default.existsSync(import_path3.default.join(cwd, target))) {
          found = true;
          break;
        }
        cwd = import_path3.default.dirname(cwd);
      }
      if (found) {
        return cwd;
      }
      return null;
    }
    var searchUp_default = searchUp;
    function getTurboRoot2(cwd) {
      let root = searchUp_default({ target: "turbo.json", cwd: cwd || process.cwd() });
      if (!root) {
        root = findRootSync(process.cwd());
        if (!root) {
          return null;
        }
      }
      return root;
    }
    var getTurboRoot_default = getTurboRoot2;
  }
});

// lib/index.ts
var lib_exports = {};
__export(lib_exports, {
  configs: () => configs,
  rules: () => rules
});
module.exports = __toCommonJS(lib_exports);

// lib/constants.ts
var RULES = {
  noUndeclaredEnvVars: `no-undeclared-env-vars`
};

// lib/utils/findTurboConfig.ts
var import_fs = __toESM(require("fs"));
var import_turbo_utils = __toESM(require_dist());
function findTurboConfig({ cwd }) {
  const turboRoot = (0, import_turbo_utils.getTurboRoot)(cwd);
  if (turboRoot) {
    try {
      const raw = import_fs.default.readFileSync(`${turboRoot}/turbo.json`, "utf8");
      const turboJsonContent = JSON.parse(raw);
      return turboJsonContent;
    } catch (e) {
      console.error(e);
      return null;
    }
  }
  return null;
}
var findTurboConfig_default = findTurboConfig;

// lib/utils/getEnvVarDependencies.ts
function findDependsOnEnvVars({
  dependencies
}) {
  if (dependencies) {
    return dependencies.filter((dep) => dep.startsWith("$")).map((envVar) => envVar.slice(1, envVar.length));
  }
  return [];
}
function getEnvVarDependencies({
  cwd,
  turboConfig
}) {
  const turboJsonContent = turboConfig || findTurboConfig_default({ cwd });
  if (!turboJsonContent) {
    return null;
  }
  const {
    globalDependencies,
    globalEnv = [],
    pipeline = {}
  } = turboJsonContent;
  const allEnvVars = [
    ...findDependsOnEnvVars({
      dependencies: globalDependencies
    }),
    ...globalEnv
  ];
  Object.values(pipeline).forEach(({ env, dependsOn }) => {
    if (dependsOn) {
      allEnvVars.push(...findDependsOnEnvVars({ dependencies: dependsOn }));
    }
    if (env) {
      allEnvVars.push(...env);
    }
  });
  return new Set(allEnvVars);
}
var getEnvVarDependencies_default = getEnvVarDependencies;

// lib/rules/no-undeclared-env-vars.ts
var meta = {
  type: "problem",
  docs: {
    description: "Do not allow the use of `process.env` without including the env key in turbo.json",
    category: "Configuration Issues",
    recommended: true,
    url: `https://github.com/vercel/turborepo/tree/main/packages/eslint-plugin-turbo/docs/rules/${RULES.noUndeclaredEnvVars}.md`
  },
  schema: [
    {
      type: "object",
      default: {},
      additionalProperties: false,
      properties: {
        turboConfig: {
          require: false,
          type: "object"
        },
        allowList: {
          default: [],
          type: "array",
          items: {
            type: "string"
          }
        }
      }
    }
  ]
};
function create(context) {
  var _a, _b;
  const { options } = context;
  const allowList = ((_a = options == null ? void 0 : options[0]) == null ? void 0 : _a.allowList) || [];
  const regexAllowList = [];
  allowList.forEach((allowed) => {
    try {
      regexAllowList.push(new RegExp(allowed));
    } catch (err) {
      console.error(`Unable to convert "${allowed}" to regex`);
    }
  });
  const turboConfig = (_b = options == null ? void 0 : options[0]) == null ? void 0 : _b.turboConfig;
  const turboVars = getEnvVarDependencies_default({
    cwd: context.getCwd(),
    turboConfig
  });
  if (!turboVars) {
    return {};
  }
  const checkKey = (node, envKey) => {
    if (envKey && !turboVars.has(envKey) && !regexAllowList.some((regex) => regex.test(envKey))) {
      context.report({
        node,
        message: "${{ envKey }} is not listed as a dependency in turbo.json",
        data: { envKey }
      });
    }
  };
  const isComputed = (node) => {
    if ("computed" in node.parent) {
      return node.parent.computed;
    }
    return false;
  };
  return {
    MemberExpression(node) {
      var _a2, _b2;
      if ("name" in node.object && "name" in node.property && !isComputed(node)) {
        const objectName = node.object.name;
        const propertyName = node.property.name;
        if (objectName === "process" && propertyName === "env") {
          if ("id" in node.parent && ((_a2 = node.parent.id) == null ? void 0 : _a2.type) === "ObjectPattern") {
            const values = node.parent.id.properties.values();
            Array.from(values).forEach((item) => {
              if ("key" in item && "name" in item.key) {
                checkKey(node.parent, item.key.name);
              }
            });
          } else if ("property" in node.parent && "name" in node.parent.property) {
            checkKey(node.parent, (_b2 = node.parent.property) == null ? void 0 : _b2.name);
          }
        }
      }
    }
  };
}
var rule = { create, meta };
var no_undeclared_env_vars_default = rule;

// lib/configs/recommended.ts
var config = {
  plugins: ["turbo"],
  rules: {
    [`turbo/${RULES.noUndeclaredEnvVars}`]: "error"
  }
};
var recommended_default = config;

// lib/index.ts
var rules = {
  [RULES.noUndeclaredEnvVars]: no_undeclared_env_vars_default
};
var configs = {
  recommended: recommended_default
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  configs,
  rules
});
/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
