// src/compile.ts
import path from "path";
import { createRequire } from "module";
import { createProcessor } from "@mdx-js/mdx";
import remarkGfm from "remark-gfm";
import rehypePrettyCode from "rehype-pretty-code";
import remarkReadingTime from "remark-reading-time";
import grayMatter from "gray-matter";
import {
  remarkStaticImage,
  remarkHeadings,
  remarkReplaceImports,
  structurize,
  parseMeta,
  attachMeta,
  remarkRemoveImports
} from "./mdx-plugins/index.mjs";

// src/theme.json
var theme_default = {
  name: "css-variables",
  type: "css",
  colors: {
    "editor.foreground": "#000001",
    "editor.background": "#000002"
  },
  tokenColors: [
    {
      settings: {
        foreground: "#000001"
      }
    },
    {
      scope: [
        "markup.deleted",
        "meta.diff.header.from-file",
        "punctuation.definition.deleted"
      ],
      settings: {
        foreground: "#ef6270"
      }
    },
    {
      scope: [
        "markup.inserted",
        "meta.diff.header.to-file",
        "punctuation.definition.inserted"
      ],
      settings: {
        foreground: "#4bb74a"
      }
    },
    {
      scope: [
        "keyword.operator.accessor",
        "meta.group.braces.round.function.arguments",
        "meta.template.expression",
        "markup.fenced_code meta.embedded.block"
      ],
      settings: {
        foreground: "#000001"
      }
    },
    {
      scope: "emphasis",
      settings: {
        fontStyle: "italic"
      }
    },
    {
      scope: ["strong", "markup.heading.markdown", "markup.bold.markdown"],
      settings: {
        fontStyle: "bold"
      }
    },
    {
      scope: ["markup.italic.markdown"],
      settings: {
        fontStyle: "italic"
      }
    },
    {
      scope: "meta.link.inline.markdown",
      settings: {
        fontStyle: "underline",
        foreground: "#000004"
      }
    },
    {
      scope: ["string", "markup.fenced_code", "markup.inline"],
      settings: {
        foreground: "#000005"
      }
    },
    {
      scope: ["comment", "string.quoted.docstring.multi"],
      settings: {
        foreground: "#000006"
      }
    },
    {
      scope: [
        "constant.numeric",
        "constant.language",
        "constant.other.placeholder",
        "constant.character.format.placeholder",
        "variable.language.this",
        "variable.other.object",
        "variable.other.class",
        "variable.other.constant",
        "meta.property-name",
        "meta.property-value",
        "support"
      ],
      settings: {
        foreground: "#000004"
      }
    },
    {
      scope: [
        "keyword",
        "storage.modifier",
        "storage.type",
        "storage.control.clojure",
        "entity.name.function.clojure",
        "entity.name.tag.yaml",
        "support.function.node",
        "support.type.property-name.json",
        "punctuation.separator.key-value",
        "punctuation.definition.template-expression"
      ],
      settings: {
        foreground: "#000007"
      }
    },
    {
      scope: "variable.parameter.function",
      settings: {
        foreground: "#000008"
      }
    },
    {
      scope: [
        "support.function",
        "entity.name.type",
        "entity.other.inherited-class",
        "meta.function-call",
        "meta.instance.constructor",
        "entity.other.attribute-name",
        "entity.name.function",
        "constant.keyword.clojure"
      ],
      settings: {
        foreground: "#000009"
      }
    },
    {
      scope: [
        "entity.name.tag",
        "string.quoted",
        "string.regexp",
        "string.interpolated",
        "string.template",
        "string.unquoted.plain.out.yaml",
        "keyword.other.template"
      ],
      settings: {
        foreground: "#000010"
      }
    },
    {
      scope: [
        "punctuation.definition.arguments",
        "punctuation.definition.dict",
        "punctuation.separator",
        "meta.function-call.arguments"
      ],
      settings: {
        foreground: "#000011"
      }
    },
    {
      name: "[Custom] Markdown links",
      scope: [
        "markup.underline.link",
        "punctuation.definition.metadata.markdown"
      ],
      settings: {
        foreground: "#000012"
      }
    },
    {
      name: "[Custom] Markdown list",
      scope: ["beginning.punctuation.definition.list.markdown"],
      settings: {
        foreground: "#000005"
      }
    },
    {
      name: "[Custom] Markdown punctuation definition brackets",
      scope: [
        "punctuation.definition.string.begin.markdown",
        "punctuation.definition.string.end.markdown",
        "string.other.link.title.markdown",
        "string.other.link.description.markdown"
      ],
      settings: {
        foreground: "#000007"
      }
    }
  ]
};

// src/compile.ts
import { truthy } from "./utils.mjs";
import remarkMath from "remark-math";
import rehypeKatex from "rehype-katex";
import { CODE_BLOCK_FILENAME_REGEX, CWD, DEFAULT_LOCALE } from "./constants.mjs";
globalThis.__nextra_temp_do_not_use = () => {
  import("./__temp__");
};
var require2 = createRequire(import.meta.url);
var DEFAULT_REHYPE_PRETTY_CODE_OPTIONS = {
  theme: theme_default,
  onVisitLine(node) {
    if (node.children.length === 0) {
      node.children = [{ type: "text", value: " " }];
    }
  },
  onVisitHighlightedLine(node) {
    node.properties.className.push("highlighted");
  },
  onVisitHighlightedWord(node) {
    node.properties.className = ["highlighted"];
  },
  filterMetaString: (meta) => meta.replace(CODE_BLOCK_FILENAME_REGEX, "")
};
var cachedCompilerForFormat = /* @__PURE__ */ Object.create(null);
async function compileMdx(source, loaderOptions = {}, { filePath = "", useCachedCompiler = false, isPageImport = true } = {}) {
  const { data: frontMatter, content } = grayMatter(source);
  const structurizedData = /* @__PURE__ */ Object.create(null);
  let searchIndexKey = null;
  if (typeof loaderOptions.flexsearch === "object") {
    if (loaderOptions.flexsearch.indexKey) {
      searchIndexKey = loaderOptions.flexsearch.indexKey(
        filePath,
        loaderOptions.route || "",
        loaderOptions.locale
      );
      if (searchIndexKey === "") {
        searchIndexKey = loaderOptions.locale || DEFAULT_LOCALE;
      }
    } else {
      searchIndexKey = loaderOptions.locale || DEFAULT_LOCALE;
    }
  } else if (loaderOptions.flexsearch) {
    searchIndexKey = loaderOptions.locale || DEFAULT_LOCALE;
  }
  const {
    jsx = false,
    format: _format = "mdx",
    outputFormat = "function-body",
    remarkPlugins = [],
    rehypePlugins = [],
    rehypePrettyCodeOptions
  } = {
    ...loaderOptions.mdxOptions,
    ...frontMatter.mdxOptions
  };
  const format = _format === "detect" ? filePath.endsWith(".mdx") ? "mdx" : "md" : _format;
  const {
    staticImage,
    flexsearch,
    readingTime,
    latex,
    codeHighlight,
    defaultShowCopyCode
  } = loaderOptions;
  const isFileOutsideCWD = !isPageImport && path.relative(CWD, filePath).startsWith("..");
  const compiler = useCachedCompiler && cachedCompilerForFormat[format] || (cachedCompilerForFormat[format] = createProcessor({
    jsx,
    format,
    outputFormat,
    providerImportSource: isFileOutsideCWD ? require2.resolve("nextra").replace(/index\.js$/, "mdx.mjs") : "nextra/mdx",
    remarkPlugins: [
      ...remarkPlugins,
      outputFormat === "function-body" && remarkRemoveImports,
      remarkGfm,
      remarkHeadings,
      staticImage && remarkStaticImage,
      searchIndexKey !== null && structurize(structurizedData, flexsearch),
      readingTime && remarkReadingTime,
      latex && remarkMath,
      isFileOutsideCWD && remarkReplaceImports
    ].filter(truthy),
    rehypePlugins: [
      ...rehypePlugins,
      [parseMeta, { defaultShowCopyCode }],
      codeHighlight !== false && [
        rehypePrettyCode,
        {
          ...DEFAULT_REHYPE_PRETTY_CODE_OPTIONS,
          ...rehypePrettyCodeOptions
        }
      ],
      attachMeta,
      latex && rehypeKatex
    ].filter(truthy)
  }));
  try {
    compiler.data("headingMeta", { headings: [] });
    const vFile = await compiler.process(
      filePath ? { value: content, path: filePath } : content
    );
    const headingMeta = compiler.data("headingMeta");
    const readingTime2 = vFile.data.readingTime;
    return {
      result: String(vFile),
      ...headingMeta,
      ...readingTime2 && { readingTime: readingTime2 },
      structurizedData,
      searchIndexKey,
      frontMatter
    };
  } catch (err) {
    console.error(`[nextra] Error compiling ${filePath}.`);
    throw err;
  }
}
export {
  compileMdx
};
