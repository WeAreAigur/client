import { Callout, Tab, Tabs } from 'nextra-theme-docs';
import { JokeForm } from '#/components/JokeForm';

## Installation

<Tabs items={['pnpm', 'npm', 'yarn']}>
	<Tab>
		```fish copy
		pnpm add @aigur/client
		```
	</Tab>
	<Tab>
		```fish copy
		npm i @aigur/client
		```
	</Tab>
	<Tab>
		```fish copy
		yarn add @aigur/client
		```
	</Tab>
</Tabs>

## A Simple Example

This is a simple example of a pipeline that takes a subject and returns a joke about that subject.

Btw, everything is fully typed! ðŸŽ‰


<CH.Scrollycoding>
  ### Instantiate the Client

After installing the `@aigur/client` npm package, import the `createClient` function and instantiate the client.

```ts index.ts focus=1,3
import { createClient } from '@aigur/client';

export const aigur = createClient();



























//
```

--- 
### Define Your API Keys

Pipelines use different services to generate your desired output. Define your API keys for those services in the `apiKeys` property.
It is typed for specific services (OpenAI, Stability, Google etc) but you can add additional custom keys as well.

Since we're using the OpenAI GPT-3 service in our example, we'll add our API key for that.

```ts index.ts focus=4:6
import { createClient } from '@aigur/client';

export const aigur = createClient({
  apiKeys: {
    openai: process.env.OPENAI_KEY!,
  },
});
```

--- 
### Create a New Pipeline

We'll create a new pipeline that will hold our logic. Let's name it `jokegpt`.

```ts index.ts focus=9:12
import { createClient } from '@aigur/client';

export const aigur = createClient({
  apiKeys: {
    openai: process.env.OPENAI_KEY!,
  },
});

export const jokeGptPipeline = aigur.pipeline
  .create({
    id: 'jokegpt',
  });
```

--- 
### Input/Output

Pipelines have input and output that are defined using [zod](https://github.com/colinhacks/zod).
Input and Output must be of type `z.object` (unless you're [streaming](/streaming) your results).

```ts index.ts focus=2,13:18
import { createClient } from '@aigur/client';
import { z } from 'zod';

export const aigur = createClient({
  apiKeys: {
    openai: process.env.OPENAI_KEY!,
  },
});

export const jokeGptPipeline = 
  aigur.pipeline.create({
    id: 'jokegpt',
    input: z.object({
      subject: z.string(),
    }),
    output: z.object({
      joke: z.string(),
    })
  });
```

--- 
### Go with the Flow

Now that we know what our pipeline accepts and returns, we need to define the flow of the pipeline itself.
The flow is comprised of `Nodes` that are chained together.
Each Node also has an input and an output, where the output of one Node is the input of the next Node.

We add a new Node using the `flow` builder with the `node` method. The `node` method accepts a Node (which is just a function, more on this later) and returns a function that will let you configure that Node's input (which is fully typed of course ðŸŽ‰). We can enter hardcoded values in the input's properties or access previous Nodes or the pipeline's input parameters.

In our first Node, `flow.node(replaceString)`, which accepts `text` and `modifier` as input and does a simple string replacement (replaces the string `$(text)$` with the value of the `text` input property).

We'll configure our Node's input using the second argument, the input function. The input function is a function that returns the Node's input (an Object or a `ReadableStream`). [The input function accepts an object with three properties](/valuereferencing): `prev`, `nodes` and `input`:

- `prev` is an object that contains the output of the previous Node. 
- `nodes` is an array of all previous Nodes. 
- `input` is the pipeline's input.

We want to reference our Pipeline's input (the `subject` property) so we'll use the `input` parameter which gives us access to the Pipeline's input.

The Node eventually takes our `subject` and prefixes it with the text "tell me a joke about".

```ts index.ts focus=3,17,22:27 mark=3[3:15],17[4:10],23[14:26],24[11:23]
import {
  createClient,
  replaceString
} from '@aigur/client';
import { z } from 'zod';

export const aigur = createClient({
  apiKeys: {
    openai: process.env.OPENAI_KEY!,
  },
});

export const jokeGptPipeline = 
 aigur.pipeline.create({
  id: 'jokegpt',
  input: z.object({
   subject: z.string(),
  }),
  output: z.object({
   joke: z.string(),
  }),
  flow: (flow) =>
   flow.node(replaceString, ({ input }) => ({
    text: input.subject,
    modifier: 'tell me a joke about $(text)$',
   }))
 });
```

--- 
### GPT

Next, we'll call OpenAI's GPT3 and pass the modified text as the prompt.
The `gpt3Prediction` Node accepts `prompt` as input and returns `text` as output.

```ts index.ts focus=4,28:30 mark=4[3:16],28[10:23]
import {
  createClient,
  replaceString,
  gpt3Prediction
} from '@aigur/client';
import { z } from 'zod';

export const aigur = createClient({
  apiKeys: {
    openai: process.env.OPENAI_KEY!,
  },
});

export const jokeGptPipeline = 
 aigur.pipeline.create({
  id: 'jokegpt',
  input: z.object({
   subject: z.string(),
  }),
  output: z.object({
   joke: z.string(),
  }),
  flow: (flow) =>
   flow.node(replaceString, ({ input }) => ({
    text: input.subject,
    modifier: 'tell me a joke about $(text)$',
   }))
   .node(gpt3Prediction, ({ prev }) => ({
    prompt: prev.text,
   }))
  });
```

--- 
### Output

Last thing, we need to always return the pipeline's output. 
We'll use the `output` node to map any values we want from our node to the properties defined in our Pipeline's output schema.
<Callout>
  Don't forget this step or your Pipeline won't return the expected output!
</Callout>

```ts index.ts focus=21,31:33 mark=21[4:7],32[5:8]
import {
  createClient,
  replaceString,
  gpt3Prediction
} from '@aigur/client';
import { z } from 'zod';

export const aigur = createClient({
  apiKeys: {
    openai: process.env.OPENAI_KEY!,
  },
});

export const jokeGptPipeline = 
 aigur.pipeline.create({
  id: 'jokegpt',
  input: z.object({
   subject: z.string(),
  }),
  output: z.object({
   joke: z.string(),
  }),
  flow: (flow) =>
   flow.node(replaceString, ({ input }) => ({
    text: input.subject,
    modifier: 'tell me a joke about $(text)$',
   }))
   .node(gpt3Prediction, ({ prev }) => ({
    prompt: prev.text,
   }))
   .output(({ prev }) => ({
    joke: prev.text,
   })
});
```

--- 
### Invoke it!
All that's left is to execute our pipeline. We can do that by calling the `invoke` method on the pipeline and passing the input parameters.

The output `text` is typed by the pipeline's `output` property.

```ts index.ts focus=18,21,36:38 mark=18[4:10],21[4:7],36[9:12],37[3:9]
import {
  createClient,
  replaceString,
  gpt3Prediction
} from '@aigur/client';
import { z } from 'zod';

export const aigur = createClient({
  apiKeys: {
    openai: process.env.OPENAI_KEY!,
  },
});

export const jokeGptPipeline = 
 aigur.pipeline.create({
  id: 'jokegpt',
  input: z.object({
   subject: z.string(),
  }),
  output: z.object({
   joke: z.string(),
  }),
  flow: (flow) =>
   flow.node(replaceString, ({ input }) => ({
    text: input.subject,
    modifier: 'tell me a joke about $(text)$',
   }))
   .node(gpt3Prediction, ({ prev }) => ({
    prompt: prev.text,
   }))
   .output(({ prev }) => ({
    joke: prev.text,
   })
});

const { joke } = await jokeGptPipeline.invoke({
  subject: 'a car'
});
```

</CH.Scrollycoding>

That's it, we're done! ðŸŽ‰ 

Don't be shy, give it a try!
<JokeForm />